{"version":3,"sources":["../src/client.ts","../src/base.ts","../src/environment.ts","../src/interactions.ts","../src/utils.ts","../src/post.ts","../src/search.ts","../src/spaces.ts","../src/plugins/SttTtsSpacesPlugin.ts","../src/plugins/templates.ts"],"sourcesContent":["import { elizaLogger, type IAgentRuntime } from '@elizaos/core';\nimport { ClientBase } from './base.ts';\nimport { validateTwitterConfig, type TwitterConfig } from './environment.ts';\nimport { TwitterInteractionClient } from './interactions.ts';\nimport { TwitterPostClient } from './post.ts';\nimport { TwitterSearchClient } from './search.ts';\nimport { TwitterSpaceClient } from './spaces.ts';\nimport { TwitterClient } from './types.ts';\n\n/**\n * A manager that orchestrates all specialized Twitter logic:\n * - client: base operations (login, timeline caching, etc.)\n * - post: autonomous posting logic\n * - search: searching tweets / replying logic\n * - interaction: handling mentions, replies\n * - space: launching and managing Twitter Spaces (optional)\n */\nclass TwitterManager {\n  client: ClientBase;\n  post: TwitterPostClient;\n  search: TwitterSearchClient;\n  interaction: TwitterInteractionClient;\n  space?: TwitterSpaceClient;\n\n  constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n    // Pass twitterConfig to the base client\n    this.client = new ClientBase(runtime, twitterConfig);\n\n    // Posting logic\n    this.post = new TwitterPostClient(this.client, runtime);\n\n    // Optional search logic (enabled if TWITTER_SEARCH_ENABLE is true)\n    if (twitterConfig.TWITTER_SEARCH_ENABLE) {\n      elizaLogger.warn('Twitter/X client running in a mode that:');\n      elizaLogger.warn('1. violates consent of random users');\n      elizaLogger.warn('2. burns your rate limit');\n      elizaLogger.warn('3. can get your account banned');\n      elizaLogger.warn('use at your own risk');\n      this.search = new TwitterSearchClient(this.client, runtime);\n    }\n\n    // Mentions and interactions\n    this.interaction = new TwitterInteractionClient(this.client, runtime);\n\n    // Optional Spaces logic (enabled if TWITTER_SPACES_ENABLE is true)\n    if (twitterConfig.TWITTER_SPACES_ENABLE) {\n      this.space = new TwitterSpaceClient(this.client, runtime);\n    }\n  }\n\n  async stop() {\n    elizaLogger.warn('Twitter client does not support stopping yet');\n  }\n}\n\nexport const TwitterClientInterface: TwitterClient = {\n  name: 'twitter',\n  async start(runtime: IAgentRuntime): Promise<TwitterManager> {\n    const twitterConfig: TwitterConfig = await validateTwitterConfig(runtime);\n\n    elizaLogger.log('Twitter client started');\n\n    const manager = new TwitterManager(runtime, twitterConfig);\n\n    // Initialize login/session\n    await manager.client.init();\n\n    // Start the posting loop\n    await manager.post.start();\n\n    // Start the search logic if it exists\n    if (manager.search) {\n      await manager.search.start();\n    }\n\n    // Start interactions (mentions, replies)\n    await manager.interaction.start();\n\n    // If Spaces are enabled, start the periodic check\n    if (manager.space) {\n      manager.space.startPeriodicSpaceCheck();\n    }\n\n    return manager;\n  },\n  async joinSpace(manager: TwitterManager, spaceId: string) {\n    if (manager.space) {\n      return manager.space.joinSpace(spaceId);\n    }\n    return;\n  },\n};\n","import {\n  type Content,\n  type IAgentRuntime,\n  type IImageDescriptionService,\n  type Memory,\n  type State,\n  type UUID,\n  getEmbeddingZeroVector,\n  elizaLogger,\n  stringToUuid,\n  ActionTimelineType,\n} from '@elizaos/core';\nimport {\n  type QueryTweetsResponse,\n  Scraper,\n  SearchMode,\n  type Tweet,\n} from '@flooz-link/agent-twitter-client';\nimport { EventEmitter } from 'events';\nimport type { TwitterConfig } from './environment.ts';\n\nexport function extractAnswer(text: string): string {\n  const startIndex = text.indexOf('Answer: ') + 8;\n  const endIndex = text.indexOf('<|endoftext|>', 11);\n  return text.slice(startIndex, endIndex);\n}\n\ntype TwitterProfile = {\n  id: string;\n  username: string;\n  screenName: string;\n  bio: string;\n  nicknames: string[];\n};\n\nclass RequestQueue {\n  private queue: (() => Promise<any>)[] = [];\n  private processing = false;\n\n  async add<T>(request: () => Promise<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.queue.push(async () => {\n        try {\n          const result = await request();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n      this.processQueue();\n    });\n  }\n\n  private async processQueue(): Promise<void> {\n    if (this.processing || this.queue.length === 0) {\n      return;\n    }\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const request = this.queue.shift()!;\n      try {\n        await request();\n      } catch (error) {\n        console.error('Error processing request:', error);\n        this.queue.unshift(request);\n        await this.exponentialBackoff(this.queue.length);\n      }\n      await this.randomDelay();\n    }\n\n    this.processing = false;\n  }\n\n  private async exponentialBackoff(retryCount: number): Promise<void> {\n    const delay = Math.pow(2, retryCount) * 1000;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n  private async randomDelay(): Promise<void> {\n    const delay = Math.floor(Math.random() * 2000) + 1500;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n  }\n}\n\nexport class ClientBase extends EventEmitter {\n  static _twitterClients: { [accountIdentifier: string]: Scraper } = {};\n  twitterClient: Scraper;\n  runtime: IAgentRuntime;\n  twitterConfig: TwitterConfig;\n  directions: string;\n  lastCheckedTweetId: bigint | null = null;\n  imageDescriptionService: IImageDescriptionService;\n  temperature = 0.5;\n\n  requestQueue: RequestQueue = new RequestQueue();\n\n  profile: TwitterProfile | null;\n\n  async cacheTweet(tweet: Tweet): Promise<void> {\n    if (!tweet) {\n      console.warn('Tweet is undefined, skipping cache');\n      return;\n    }\n\n    this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\n  }\n\n  async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\n    const cached = await this.runtime.cacheManager.get<Tweet>(\n      `twitter/tweets/${tweetId}`,\n    );\n\n    return cached;\n  }\n\n  async getTweet(tweetId: string): Promise<Tweet> {\n    const cachedTweet = await this.getCachedTweet(tweetId);\n\n    if (cachedTweet) {\n      return cachedTweet;\n    }\n\n    const tweet = await this.requestQueue.add(() =>\n      this.twitterClient.getTweet(tweetId),\n    );\n\n    await this.cacheTweet(tweet);\n    return tweet;\n  }\n\n  callback: (self: ClientBase) => any = null;\n\n  onReady() {\n    throw new Error('Not implemented in base class, please call from subclass');\n  }\n\n  /**\n   * Parse the raw tweet data into a standardized Tweet object.\n   */\n  private parseTweet(raw: any, depth = 0, maxDepth = 3): Tweet {\n    // If we've reached maxDepth, don't parse nested quotes/retweets further\n    const canRecurse = depth < maxDepth;\n\n    const quotedStatus =\n      raw.quoted_status_result?.result && canRecurse\n        ? this.parseTweet(raw.quoted_status_result.result, depth + 1, maxDepth)\n        : undefined;\n\n    const retweetedStatus =\n      raw.retweeted_status_result?.result && canRecurse\n        ? this.parseTweet(\n            raw.retweeted_status_result.result,\n            depth + 1,\n            maxDepth,\n          )\n        : undefined;\n\n    const t: Tweet = {\n      bookmarkCount:\n        raw.bookmarkCount ?? raw.legacy?.bookmark_count ?? undefined,\n      conversationId: raw.conversationId ?? raw.legacy?.conversation_id_str,\n      hashtags: raw.hashtags ?? raw.legacy?.entities?.hashtags ?? [],\n      html: raw.html,\n      id: raw.id ?? raw.rest_id ?? raw.id_str ?? undefined,\n      inReplyToStatus: raw.inReplyToStatus,\n      inReplyToStatusId:\n        raw.inReplyToStatusId ??\n        raw.legacy?.in_reply_to_status_id_str ??\n        undefined,\n      isQuoted: raw.legacy?.is_quote_status === true,\n      isPin: raw.isPin,\n      isReply: raw.isReply,\n      isRetweet: raw.legacy?.retweeted === true,\n      isSelfThread: raw.isSelfThread,\n      // @ts-ignore\n      language: raw.legacy?.lang,\n      likes: raw.legacy?.favorite_count ?? 0,\n      name:\n        raw.name ??\n        raw?.user_results?.result?.legacy?.name ??\n        raw.core?.user_results?.result?.legacy?.name,\n      mentions: raw.mentions ?? raw.legacy?.entities?.user_mentions ?? [],\n      permanentUrl:\n        raw.permanentUrl ??\n        (raw.core?.user_results?.result?.legacy?.screen_name && raw.rest_id\n          ? `https://x.com/${raw.core?.user_results?.result?.legacy?.screen_name}/status/${raw.rest_id}`\n          : undefined),\n      photos:\n        raw.photos ??\n        (raw.legacy?.entities?.media\n          ?.filter((media: any) => media.type === 'photo')\n          .map((media: any) => ({\n            id: media.id_str,\n            url: media.media_url_https,\n            alt_text: media.alt_text,\n          })) ||\n          []),\n      place: raw.place,\n      poll: raw.poll ?? null,\n      quotedStatus,\n      quotedStatusId:\n        raw.quotedStatusId ?? raw.legacy?.quoted_status_id_str ?? undefined,\n      quotes: raw.legacy?.quote_count ?? 0,\n      replies: raw.legacy?.reply_count ?? 0,\n      retweets: raw.legacy?.retweet_count ?? 0,\n      retweetedStatus,\n      retweetedStatusId: raw.legacy?.retweeted_status_id_str ?? undefined,\n      text: raw.text ?? raw.legacy?.full_text ?? undefined,\n      thread: raw.thread || [],\n      timeParsed: raw.timeParsed\n        ? new Date(raw.timeParsed)\n        : raw.legacy?.created_at\n          ? new Date(raw.legacy?.created_at)\n          : undefined,\n      timestamp:\n        raw.timestamp ??\n        (raw.legacy?.created_at\n          ? new Date(raw.legacy.created_at).getTime() / 1000\n          : undefined),\n      urls: raw.urls ?? raw.legacy?.entities?.urls ?? [],\n      userId: raw.userId ?? raw.legacy?.user_id_str ?? undefined,\n      username:\n        raw.username ??\n        raw.core?.user_results?.result?.legacy?.screen_name ??\n        undefined,\n      videos:\n        raw.videos ??\n        raw.legacy?.entities?.media?.filter(\n          (media: any) => media.type === 'video',\n        ) ??\n        [],\n      views: raw.views?.count ? Number(raw.views.count) : 0,\n      sensitiveContent: raw.sensitiveContent,\n    };\n\n    return t;\n  }\n\n  constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n    super();\n    this.runtime = runtime;\n    this.twitterConfig = twitterConfig;\n    const username = twitterConfig.TWITTER_USERNAME;\n    if (ClientBase._twitterClients[username]) {\n      this.twitterClient = ClientBase._twitterClients[username];\n    } else {\n      this.twitterClient = new Scraper();\n      ClientBase._twitterClients[username] = this.twitterClient;\n    }\n\n    this.directions =\n      '- ' +\n      this.runtime.character.style.all.join('\\n- ') +\n      '- ' +\n      this.runtime.character.style.post.join();\n  }\n\n  async init() {\n    const username = this.twitterConfig.TWITTER_USERNAME;\n    const password = this.twitterConfig.TWITTER_PASSWORD;\n    const email = this.twitterConfig.TWITTER_EMAIL;\n    let retries = this.twitterConfig.TWITTER_RETRY_LIMIT;\n    const twitter2faSecret = this.twitterConfig.TWITTER_2FA_SECRET;\n\n    if (!username) {\n      throw new Error('Twitter username not configured');\n    }\n\n    const authToken = this.runtime.getSetting('TWITTER_COOKIES_AUTH_TOKEN');\n    const ct0 = this.runtime.getSetting('TWITTER_COOKIES_CT0');\n    const guestId = this.runtime.getSetting('TWITTER_COOKIES_GUEST_ID');\n\n    const createTwitterCookies = (\n      authToken: string,\n      ct0: string,\n      guestId: string,\n    ) =>\n      authToken && ct0 && guestId\n        ? [\n            { key: 'auth_token', value: authToken, domain: '.twitter.com' },\n            { key: 'ct0', value: ct0, domain: '.twitter.com' },\n            { key: 'guest_id', value: guestId, domain: '.twitter.com' },\n          ]\n        : null;\n\n    const cachedCookies =\n      (await this.getCachedCookies(username)) ||\n      createTwitterCookies(authToken, ct0, guestId);\n\n    if (cachedCookies) {\n      elizaLogger.info('Using cached cookies');\n      await this.setCookiesFromArray(cachedCookies);\n    }\n\n    elizaLogger.log('Waiting for Twitter login');\n    while (retries > 0) {\n      try {\n        if (await this.twitterClient.isLoggedIn()) {\n          // cookies are valid, no login required\n          elizaLogger.info('Successfully logged in.');\n          break;\n        } else {\n          await this.twitterClient.login(\n            username,\n            password,\n            email,\n            twitter2faSecret,\n          );\n          if (await this.twitterClient.isLoggedIn()) {\n            // fresh login, store new cookies\n            elizaLogger.info('Successfully logged in.');\n            elizaLogger.info('Caching cookies');\n            await this.cacheCookies(\n              username,\n              await this.twitterClient.getCookies(),\n            );\n            break;\n          }\n        }\n      } catch (error) {\n        elizaLogger.error(`Login attempt failed: ${error.message}`);\n      }\n\n      retries--;\n      elizaLogger.error(\n        `Failed to login to Twitter. Retrying... (${retries} attempts left)`,\n      );\n\n      if (retries === 0) {\n        elizaLogger.error('Max retries reached. Exiting login process.');\n        throw new Error('Twitter login failed after maximum retries.');\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n    }\n    // Initialize Twitter profile\n    this.profile = await this.fetchProfile(username);\n\n    if (this.profile) {\n      elizaLogger.log('Twitter user ID:', this.profile.id);\n      elizaLogger.log(\n        'Twitter loaded:',\n        JSON.stringify(this.profile, null, 10),\n      );\n      // Store profile info for use in responses\n      this.runtime.character.twitterProfile = {\n        id: this.profile.id,\n        username: this.profile.username,\n        screenName: this.profile.screenName,\n        bio: this.profile.bio,\n        nicknames: this.profile.nicknames,\n      };\n    } else {\n      throw new Error('Failed to load profile');\n    }\n\n    await this.loadLatestCheckedTweetId();\n    await this.populateTimeline();\n  }\n\n  async fetchOwnPosts(count: number): Promise<Tweet[]> {\n    elizaLogger.debug('fetching own posts');\n    const homeTimeline = await this.twitterClient.getUserTweets(\n      this.profile.id,\n      count,\n    );\n    // Use parseTweet on each tweet\n    return homeTimeline.tweets.map((t) => this.parseTweet(t));\n  }\n\n  /**\n   * Fetch timeline for twitter account, optionally only from followed accounts\n   */\n  async fetchHomeTimeline(\n    count: number,\n    following?: boolean,\n  ): Promise<Tweet[]> {\n    elizaLogger.debug('fetching home timeline');\n    const homeTimeline = following\n      ? await this.twitterClient.fetchFollowingTimeline(count, [])\n      : await this.twitterClient.fetchHomeTimeline(count, []);\n\n    elizaLogger.debug(homeTimeline, { depth: Number.POSITIVE_INFINITY });\n    const processedTimeline = homeTimeline\n      .filter((t) => t.__typename !== 'TweetWithVisibilityResults') // what's this about?\n      .map((tweet) => this.parseTweet(tweet));\n\n    //elizaLogger.debug(\"process homeTimeline\", processedTimeline);\n    return processedTimeline;\n  }\n\n  async fetchTimelineForActions(count: number): Promise<Tweet[]> {\n    elizaLogger.debug('fetching timeline for actions');\n\n    const agentUsername = this.twitterConfig.TWITTER_USERNAME;\n\n    const homeTimeline =\n      this.twitterConfig.ACTION_TIMELINE_TYPE === ActionTimelineType.Following\n        ? await this.twitterClient.fetchFollowingTimeline(count, [])\n        : await this.twitterClient.fetchHomeTimeline(count, []);\n\n    // Parse, filter out self-tweets, limit to count\n    return homeTimeline\n      .map((tweet) => this.parseTweet(tweet))\n      .filter((tweet) => tweet.username !== agentUsername) // do not perform action on self-tweets\n      .slice(0, count);\n    // TODO: Once the 'count' parameter is fixed in the 'fetchTimeline' method of the 'agent-twitter-client',\n    // this workaround can be removed.\n    // Related issue: https://github.com/elizaos/agent-twitter-client/issues/43\n  }\n\n  async fetchSearchTweets(\n    query: string,\n    maxTweets: number,\n    searchMode: SearchMode,\n    cursor?: string,\n  ): Promise<QueryTweetsResponse> {\n    try {\n      // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n      // if we dont get a response in 5 seconds, something is wrong\n      const timeoutPromise = new Promise((resolve) =>\n        setTimeout(() => resolve({ tweets: [] }), 15000),\n      );\n\n      try {\n        const result = await this.requestQueue.add(\n          async () =>\n            await Promise.race([\n              this.twitterClient.fetchSearchTweets(\n                query,\n                maxTweets,\n                searchMode,\n                cursor,\n              ),\n              timeoutPromise,\n            ]),\n        );\n        return (result ?? { tweets: [] }) as QueryTweetsResponse;\n      } catch (error) {\n        elizaLogger.error('Error fetching search tweets:', error);\n        return { tweets: [] };\n      }\n    } catch (error) {\n      elizaLogger.error('Error fetching search tweets:', error);\n      return { tweets: [] };\n    }\n  }\n\n  private async populateTimeline() {\n    elizaLogger.debug('populating timeline...');\n\n    const cachedTimeline = await this.getCachedTimeline();\n\n    // Check if the cache file exists\n    if (cachedTimeline) {\n      // Read the cached search results from the file\n\n      // Get the existing memories from the database\n      const existingMemories =\n        await this.runtime.messageManager.getMemoriesByRoomIds({\n          roomIds: cachedTimeline.map((tweet) =>\n            stringToUuid(tweet.conversationId + '-' + this.runtime.agentId),\n          ),\n        });\n\n      //TODO: load tweets not in cache?\n\n      // Create a Set to store the IDs of existing memories\n      const existingMemoryIds = new Set(\n        existingMemories.map((memory) => memory.id.toString()),\n      );\n\n      // Check if any of the cached tweets exist in the existing memories\n      const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n        existingMemoryIds.has(\n          stringToUuid(tweet.id + '-' + this.runtime.agentId),\n        ),\n      );\n\n      if (someCachedTweetsExist) {\n        // Filter out the cached tweets that already exist in the database\n        const tweetsToSave = cachedTimeline.filter(\n          (tweet) =>\n            !existingMemoryIds.has(\n              stringToUuid(tweet.id + '-' + this.runtime.agentId),\n            ),\n        );\n\n        console.log({\n          processingTweets: tweetsToSave.map((tweet) => tweet.id).join(','),\n        });\n\n        // Save the missing tweets as memories\n        for (const tweet of tweetsToSave) {\n          elizaLogger.log('Saving Tweet', tweet.id);\n\n          const roomId = stringToUuid(\n            tweet.conversationId + '-' + this.runtime.agentId,\n          );\n\n          const userId =\n            tweet.userId === this.profile.id\n              ? this.runtime.agentId\n              : stringToUuid(tweet.userId);\n\n          if (tweet.userId === this.profile.id) {\n            await this.runtime.ensureConnection(\n              this.runtime.agentId,\n              roomId,\n              this.profile.username,\n              this.profile.screenName,\n              'twitter',\n            );\n          } else {\n            await this.runtime.ensureConnection(\n              userId,\n              roomId,\n              tweet.username,\n              tweet.name,\n              'twitter',\n            );\n          }\n\n          const content = {\n            text: tweet.text,\n            url: tweet.permanentUrl,\n            source: 'twitter',\n            inReplyTo: tweet.inReplyToStatusId\n              ? stringToUuid(\n                  tweet.inReplyToStatusId + '-' + this.runtime.agentId,\n                )\n              : undefined,\n          } as Content;\n\n          elizaLogger.log('Creating memory for tweet', tweet.id);\n\n          // check if it already exists\n          const memory = await this.runtime.messageManager.getMemoryById(\n            stringToUuid(tweet.id + '-' + this.runtime.agentId),\n          );\n\n          if (memory) {\n            elizaLogger.log(\n              'Memory already exists, skipping timeline population',\n            );\n            break;\n          }\n\n          await this.runtime.messageManager.createMemory({\n            id: stringToUuid(tweet.id + '-' + this.runtime.agentId),\n            userId,\n            content: content,\n            agentId: this.runtime.agentId,\n            roomId,\n            embedding: getEmbeddingZeroVector(),\n            createdAt: tweet.timestamp * 1000,\n          });\n\n          await this.cacheTweet(tweet);\n        }\n\n        elizaLogger.log(\n          `Populated ${tweetsToSave.length} missing tweets from the cache.`,\n        );\n        return;\n      }\n    }\n\n    const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\n    const username = this.twitterConfig.TWITTER_USERNAME;\n\n    // Get the most recent 20 mentions and interactions\n    const mentionsAndInteractions = await this.fetchSearchTweets(\n      `@${username}`,\n      20,\n      SearchMode.Latest,\n    );\n\n    // Combine the timeline tweets and mentions/interactions\n    const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n\n    // Create a Set to store unique tweet IDs\n    const tweetIdsToCheck = new Set<string>();\n    const roomIds = new Set<UUID>();\n\n    // Add tweet IDs to the Set\n    for (const tweet of allTweets) {\n      tweetIdsToCheck.add(tweet.id);\n      roomIds.add(\n        stringToUuid(tweet.conversationId + '-' + this.runtime.agentId),\n      );\n    }\n\n    // Check the existing memories in the database\n    const existingMemories =\n      await this.runtime.messageManager.getMemoriesByRoomIds({\n        roomIds: Array.from(roomIds),\n      });\n\n    // Create a Set to store the existing memory IDs\n    const existingMemoryIds = new Set<UUID>(\n      existingMemories.map((memory) => memory.id),\n    );\n\n    // Filter out the tweets that already exist in the database\n    const tweetsToSave = allTweets.filter(\n      (tweet) =>\n        !existingMemoryIds.has(\n          stringToUuid(tweet.id + '-' + this.runtime.agentId),\n        ),\n    );\n\n    elizaLogger.debug({\n      processingTweets: tweetsToSave.map((tweet) => tweet.id).join(','),\n    });\n\n    await this.runtime.ensureUserExists(\n      this.runtime.agentId,\n      this.profile.username,\n      this.runtime.character.name,\n      'twitter',\n    );\n\n    // Save the new tweets as memories\n    for (const tweet of tweetsToSave) {\n      elizaLogger.log('Saving Tweet', tweet.id);\n\n      const roomId = stringToUuid(\n        tweet.conversationId + '-' + this.runtime.agentId,\n      );\n      const userId =\n        tweet.userId === this.profile.id\n          ? this.runtime.agentId\n          : stringToUuid(tweet.userId);\n\n      if (tweet.userId === this.profile.id) {\n        await this.runtime.ensureConnection(\n          this.runtime.agentId,\n          roomId,\n          this.profile.username,\n          this.profile.screenName,\n          'twitter',\n        );\n      } else {\n        await this.runtime.ensureConnection(\n          userId,\n          roomId,\n          tweet.username,\n          tweet.name,\n          'twitter',\n        );\n      }\n\n      const content = {\n        text: tweet.text,\n        url: tweet.permanentUrl,\n        source: 'twitter',\n        inReplyTo: tweet.inReplyToStatusId\n          ? stringToUuid(tweet.inReplyToStatusId)\n          : undefined,\n      } as Content;\n\n      await this.runtime.messageManager.createMemory({\n        id: stringToUuid(tweet.id + '-' + this.runtime.agentId),\n        userId,\n        content: content,\n        agentId: this.runtime.agentId,\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: tweet.timestamp * 1000,\n      });\n\n      await this.cacheTweet(tweet);\n    }\n\n    // Cache\n    await this.cacheTimeline(timeline);\n    await this.cacheMentions(mentionsAndInteractions.tweets);\n  }\n\n  async setCookiesFromArray(cookiesArray: any[]) {\n    const cookieStrings = cookiesArray.map(\n      (cookie) =>\n        `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\n          cookie.secure ? 'Secure' : ''\n        }; ${cookie.httpOnly ? 'HttpOnly' : ''}; SameSite=${\n          cookie.sameSite || 'Lax'\n        }`,\n    );\n    await this.twitterClient.setCookies(cookieStrings);\n  }\n\n  async saveRequestMessage(message: Memory, state: State) {\n    if (message.content.text) {\n      const recentMessage = await this.runtime.messageManager.getMemories({\n        roomId: message.roomId,\n        count: 1,\n        unique: false,\n      });\n\n      if (\n        recentMessage.length > 0 &&\n        recentMessage[0].content === message.content\n      ) {\n        elizaLogger.debug('Message already saved', recentMessage[0].id);\n      } else {\n        await this.runtime.messageManager.createMemory({\n          ...message,\n          embedding: getEmbeddingZeroVector(),\n        });\n      }\n\n      await this.runtime.evaluate(message, {\n        ...state,\n        twitterClient: this.twitterClient,\n      });\n    }\n  }\n\n  async loadLatestCheckedTweetId(): Promise<void> {\n    const latestCheckedTweetId = await this.runtime.cacheManager.get<string>(\n      `twitter/${this.profile.username}/latest_checked_tweet_id`,\n    );\n\n    if (latestCheckedTweetId) {\n      this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\n    }\n  }\n\n  async cacheLatestCheckedTweetId() {\n    if (this.lastCheckedTweetId) {\n      await this.runtime.cacheManager.set(\n        `twitter/${this.profile.username}/latest_checked_tweet_id`,\n        this.lastCheckedTweetId.toString(),\n      );\n    }\n  }\n\n  async getCachedTimeline(): Promise<Tweet[] | undefined> {\n    return await this.runtime.cacheManager.get<Tweet[]>(\n      `twitter/${this.profile.username}/timeline`,\n    );\n  }\n\n  async cacheTimeline(timeline: Tweet[]) {\n    await this.runtime.cacheManager.set(\n      `twitter/${this.profile.username}/timeline`,\n      timeline,\n      { expires: Date.now() + 10 * 1000 },\n    );\n  }\n\n  async cacheMentions(mentions: Tweet[]) {\n    await this.runtime.cacheManager.set(\n      `twitter/${this.profile.username}/mentions`,\n      mentions,\n      { expires: Date.now() + 10 * 1000 },\n    );\n  }\n\n  async getCachedCookies(username: string) {\n    return await this.runtime.cacheManager.get<any[]>(\n      `twitter/${username}/cookies`,\n    );\n  }\n\n  async cacheCookies(username: string, cookies: any[]) {\n    await this.runtime.cacheManager.set(`twitter/${username}/cookies`, cookies);\n  }\n\n  async fetchProfile(username: string): Promise<TwitterProfile> {\n    try {\n      const profile = await this.requestQueue.add(async () => {\n        const profile = await this.twitterClient.getProfile(username);\n        return {\n          id: profile.userId,\n          username,\n          screenName: profile.name || this.runtime.character.name,\n          bio:\n            profile.biography || typeof this.runtime.character.bio === 'string'\n              ? (this.runtime.character.bio as string)\n              : this.runtime.character.bio.length > 0\n                ? this.runtime.character.bio[0]\n                : '',\n          nicknames: this.runtime.character.twitterProfile?.nicknames || [],\n        } satisfies TwitterProfile;\n      });\n\n      return profile;\n    } catch (error) {\n      console.error('Error fetching Twitter profile:', error);\n      throw error;\n    }\n  }\n}\n","import {\n  parseBooleanFromText,\n  type IAgentRuntime,\n  ActionTimelineType,\n} from '@elizaos/core';\nimport { z, ZodError } from 'zod';\n\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\n\nconst twitterUsernameSchema = z\n  .string()\n  .min(1, 'An X/Twitter Username must be at least 1 character long')\n  .max(15, 'An X/Twitter Username cannot exceed 15 characters')\n  .refine((username) => {\n    // Allow wildcard '*' as a special case\n    if (username === '*') return true;\n\n    // Twitter usernames can:\n    // - Start with digits now\n    // - Contain letters, numbers, underscores\n    // - Must not be empty\n    return /^[A-Za-z0-9_]+$/.test(username);\n  }, 'An X Username can only contain letters, numbers, and underscores');\n\n/**\n * This schema defines all required/optional environment settings,\n * including new fields like TWITTER_SPACES_ENABLE.\n */\nexport const twitterEnvSchema = z.object({\n  TWITTER_DRY_RUN: z.boolean(),\n  TWITTER_USERNAME: z.string().min(1, 'X/Twitter username is required'),\n  TWITTER_PASSWORD: z.string().min(1, 'X/Twitter password is required'),\n  TWITTER_EMAIL: z.string().email('Valid X/Twitter email is required'),\n  MAX_TWEET_LENGTH: z.number().int().default(DEFAULT_MAX_TWEET_LENGTH),\n  TWITTER_SEARCH_ENABLE: z.boolean().default(false),\n  TWITTER_2FA_SECRET: z.string(),\n  TWITTER_RETRY_LIMIT: z.number().int(),\n  TWITTER_POLL_INTERVAL: z.number().int(),\n  TWITTER_TARGET_USERS: z.array(twitterUsernameSchema).default([]),\n  // I guess it's possible to do the transformation with zod\n  // not sure it's preferable, maybe a readability issue\n  // since more people will know js/ts than zod\n  /*\n        z\n        .string()\n        .transform((val) => val.trim())\n        .pipe(\n            z.string()\n                .transform((val) =>\n                    val ? val.split(',').map((u) => u.trim()).filter(Boolean) : []\n                )\n                .pipe(\n                    z.array(\n                        z.string()\n                            .min(1)\n                            .max(15)\n                            .regex(\n                                /^[A-Za-z][A-Za-z0-9_]*[A-Za-z0-9]$|^[A-Za-z]$/,\n                                'Invalid Twitter username format'\n                            )\n                    )\n                )\n                .transform((users) => users.join(','))\n        )\n        .optional()\n        .default(''),\n    */\n  ENABLE_TWITTER_POST_GENERATION: z.boolean(),\n  POST_INTERVAL_MIN: z.number().int(),\n  POST_INTERVAL_MAX: z.number().int(),\n  ENABLE_ACTION_PROCESSING: z.boolean(),\n  ACTION_INTERVAL: z.number().int(),\n  POST_IMMEDIATELY: z.boolean(),\n  TWITTER_SPACES_ENABLE: z.boolean().default(false),\n  MAX_ACTIONS_PROCESSING: z.number().int(),\n  ACTION_TIMELINE_TYPE: z\n    .nativeEnum(ActionTimelineType)\n    .default(ActionTimelineType.ForYou),\n});\n\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\n\n/**\n * Helper to parse a comma-separated list of Twitter usernames\n * (already present in your code).\n */\nfunction parseTargetUsers(targetUsersStr?: string | null): string[] {\n  if (!targetUsersStr?.trim()) {\n    return [];\n  }\n  return targetUsersStr\n    .split(',')\n    .map((user) => user.trim())\n    .filter(Boolean);\n}\n\nfunction safeParseInt(\n  value: string | undefined | null,\n  defaultValue: number,\n): number {\n  if (!value) return defaultValue;\n  const parsed = Number.parseInt(value, 10);\n  return isNaN(parsed) ? defaultValue : Math.max(1, parsed);\n}\n\n/**\n * Validates or constructs a TwitterConfig object using zod,\n * taking values from the IAgentRuntime or process.env as needed.\n */\n// This also is organized to serve as a point of documentation for the client\n// most of the inputs from the framework (env/character)\n\n// we also do a lot of typing/parsing here\n// so we can do it once and only once per character\nexport async function validateTwitterConfig(\n  runtime: IAgentRuntime,\n): Promise<TwitterConfig> {\n  try {\n    const twitterConfig = {\n      TWITTER_DRY_RUN:\n        parseBooleanFromText(\n          runtime.getSetting('TWITTER_DRY_RUN') || process.env.TWITTER_DRY_RUN,\n        ) ?? false, // parseBooleanFromText return null if \"\", map \"\" to false\n\n      TWITTER_USERNAME:\n        runtime.getSetting('TWITTER_USERNAME') || process.env.TWITTER_USERNAME,\n\n      TWITTER_PASSWORD:\n        runtime.getSetting('TWITTER_PASSWORD') || process.env.TWITTER_PASSWORD,\n\n      TWITTER_EMAIL:\n        runtime.getSetting('TWITTER_EMAIL') || process.env.TWITTER_EMAIL,\n\n      // number as string?\n      MAX_TWEET_LENGTH: safeParseInt(\n        runtime.getSetting('MAX_TWEET_LENGTH') || process.env.MAX_TWEET_LENGTH,\n        DEFAULT_MAX_TWEET_LENGTH,\n      ),\n\n      TWITTER_SEARCH_ENABLE:\n        parseBooleanFromText(\n          runtime.getSetting('TWITTER_SEARCH_ENABLE') ||\n            process.env.TWITTER_SEARCH_ENABLE,\n        ) ?? false,\n\n      // string passthru\n      TWITTER_2FA_SECRET:\n        runtime.getSetting('TWITTER_2FA_SECRET') ||\n        process.env.TWITTER_2FA_SECRET ||\n        '',\n\n      // int\n      TWITTER_RETRY_LIMIT: safeParseInt(\n        runtime.getSetting('TWITTER_RETRY_LIMIT') ||\n          process.env.TWITTER_RETRY_LIMIT,\n        5,\n      ),\n\n      // int in seconds\n      TWITTER_POLL_INTERVAL: safeParseInt(\n        runtime.getSetting('TWITTER_POLL_INTERVAL') ||\n          process.env.TWITTER_POLL_INTERVAL,\n        120, // 2m\n      ),\n\n      // comma separated string\n      TWITTER_TARGET_USERS: parseTargetUsers(\n        runtime.getSetting('TWITTER_TARGET_USERS') ||\n          process.env.TWITTER_TARGET_USERS,\n      ),\n\n      // bool\n      ENABLE_TWITTER_POST_GENERATION:\n        parseBooleanFromText(\n          runtime.getSetting('ENABLE_TWITTER_POST_GENERATION') ||\n            process.env.ENABLE_TWITTER_POST_GENERATION,\n        ) ?? true,\n\n      // int in minutes\n      POST_INTERVAL_MIN: safeParseInt(\n        runtime.getSetting('POST_INTERVAL_MIN') ||\n          process.env.POST_INTERVAL_MIN,\n        90, // 1.5 hours\n      ),\n\n      // int in minutes\n      POST_INTERVAL_MAX: safeParseInt(\n        runtime.getSetting('POST_INTERVAL_MAX') ||\n          process.env.POST_INTERVAL_MAX,\n        180, // 3 hours\n      ),\n\n      // bool\n      ENABLE_ACTION_PROCESSING:\n        parseBooleanFromText(\n          runtime.getSetting('ENABLE_ACTION_PROCESSING') ||\n            process.env.ENABLE_ACTION_PROCESSING,\n        ) ?? false,\n\n      // init in minutes (min 1m)\n      ACTION_INTERVAL: safeParseInt(\n        runtime.getSetting('ACTION_INTERVAL') || process.env.ACTION_INTERVAL,\n        5, // 5 minutes\n      ),\n\n      // bool\n      POST_IMMEDIATELY:\n        parseBooleanFromText(\n          runtime.getSetting('POST_IMMEDIATELY') ||\n            process.env.POST_IMMEDIATELY,\n        ) ?? false,\n\n      TWITTER_SPACES_ENABLE:\n        parseBooleanFromText(\n          runtime.getSetting('TWITTER_SPACES_ENABLE') ||\n            process.env.TWITTER_SPACES_ENABLE,\n        ) ?? false,\n\n      MAX_ACTIONS_PROCESSING: safeParseInt(\n        runtime.getSetting('MAX_ACTIONS_PROCESSING') ||\n          process.env.MAX_ACTIONS_PROCESSING,\n        1,\n      ),\n\n      ACTION_TIMELINE_TYPE:\n        runtime.getSetting('ACTION_TIMELINE_TYPE') ||\n        process.env.ACTION_TIMELINE_TYPE,\n    };\n\n    return twitterEnvSchema.parse(twitterConfig);\n  } catch (error) {\n    if (error instanceof ZodError) {\n      const errorMessages = error.errors\n        .map((err) => `${err.path.join('.')}: ${err.message}`)\n        .join('\\n');\n      throw new Error(\n        `X/Twitter configuration validation failed:\\n${errorMessages}`,\n      );\n    }\n    throw error;\n  }\n}\n","import { SearchMode, type Tweet } from '@flooz-link/agent-twitter-client';\nimport {\n  composeContext,\n  generateMessageResponse,\n  generateShouldRespond,\n  messageCompletionFooter,\n  shouldRespondFooter,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelClass,\n  type State,\n  stringToUuid,\n  elizaLogger,\n  getEmbeddingZeroVector,\n  type IImageDescriptionService,\n  ServiceType,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport { buildConversationThread, sendTweet, wait } from './utils.ts';\n\nexport const twitterMessageHandlerTemplate =\n  `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\n{{recentPosts}}\n\n# TASK: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\n\nCurrent Post:\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\n{{actions}}\n\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n` + messageCompletionFooter;\n\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\n  `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\n\nFor other users:\n- {{agentName}} should RESPOND to messages directed at them\n- {{agentName}} should RESPOND to conversations relevant to their background\n- {{agentName}} should IGNORE irrelevant messages\n- {{agentName}} should IGNORE very short messages unless directly addressed\n- {{agentName}} should STOP if asked to stop\n- {{agentName}} should STOP if conversation is concluded\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n\nIMPORTANT:\n- {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n- For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\n\nRecent Posts:\n{{recentPosts}}\n\nCurrent Post:\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\n` + shouldRespondFooter;\n\nexport class TwitterInteractionClient {\n  client: ClientBase;\n  runtime: IAgentRuntime;\n  private isDryRun: boolean;\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.runtime = runtime;\n    this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n  }\n\n  async start() {\n    const handleTwitterInteractionsLoop = () => {\n      this.handleTwitterInteractions();\n      setTimeout(\n        handleTwitterInteractionsLoop,\n        // Defaults to 2 minutes\n        this.client.twitterConfig.TWITTER_POLL_INTERVAL * 1000,\n      );\n    };\n    handleTwitterInteractionsLoop();\n  }\n\n  async handleTwitterInteractions() {\n    elizaLogger.log('Checking Twitter interactions');\n\n    const twitterUsername = this.client.profile.username;\n    try {\n      // Check for mentions\n      const mentionCandidates = (\n        await this.client.fetchSearchTweets(\n          `@${twitterUsername}`,\n          20,\n          SearchMode.Latest,\n        )\n      ).tweets;\n\n      elizaLogger.log(\n        'Completed checking mentioned tweets:',\n        mentionCandidates.length,\n      );\n      let uniqueTweetCandidates = [...mentionCandidates];\n      // Only process target users if configured\n      if (this.client.twitterConfig.TWITTER_TARGET_USERS.length) {\n        const TARGET_USERS = this.client.twitterConfig.TWITTER_TARGET_USERS;\n\n        elizaLogger.log('Processing target users:', TARGET_USERS);\n\n        if (TARGET_USERS.length > 0) {\n          // Create a map to store tweets by user\n          const tweetsByUser = new Map<string, Tweet[]>();\n\n          // Fetch tweets from all target users\n          for (const username of TARGET_USERS) {\n            try {\n              const userTweets = (\n                await this.client.twitterClient.fetchSearchTweets(\n                  `from:${username}`,\n                  3,\n                  SearchMode.Latest,\n                )\n              ).tweets;\n\n              // Filter for unprocessed, non-reply, recent tweets\n              const validTweets = userTweets.filter((tweet) => {\n                const isUnprocessed =\n                  !this.client.lastCheckedTweetId ||\n                  Number.parseInt(tweet.id) > this.client.lastCheckedTweetId;\n                const isRecent =\n                  Date.now() - tweet.timestamp * 1000 < 2 * 60 * 60 * 1000;\n\n                elizaLogger.log(`Tweet ${tweet.id} checks:`, {\n                  isUnprocessed,\n                  isRecent,\n                  isReply: tweet.isReply,\n                  isRetweet: tweet.isRetweet,\n                });\n\n                return (\n                  isUnprocessed &&\n                  !tweet.isReply &&\n                  !tweet.isRetweet &&\n                  isRecent\n                );\n              });\n\n              if (validTweets.length > 0) {\n                tweetsByUser.set(username, validTweets);\n                elizaLogger.log(\n                  `Found ${validTweets.length} valid tweets from ${username}`,\n                );\n              }\n            } catch (error) {\n              elizaLogger.error(\n                `Error fetching tweets for ${username}:`,\n                error,\n              );\n              continue;\n            }\n          }\n\n          // Select one tweet from each user that has tweets\n          const selectedTweets: Tweet[] = [];\n          for (const [username, tweets] of tweetsByUser) {\n            if (tweets.length > 0) {\n              // Randomly select one tweet from this user\n              const randomTweet =\n                tweets[Math.floor(Math.random() * tweets.length)];\n              selectedTweets.push(randomTweet);\n              elizaLogger.log(\n                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`,\n              );\n            }\n          }\n\n          // Add selected tweets to candidates\n          uniqueTweetCandidates = [...mentionCandidates, ...selectedTweets];\n        }\n      } else {\n        elizaLogger.log('No target users configured, processing only mentions');\n      }\n\n      // Sort tweet candidates by ID in ascending order\n      uniqueTweetCandidates\n        .sort((a, b) => a.id.localeCompare(b.id))\n        .filter((tweet) => tweet.userId !== this.client.profile.id);\n\n      // for each tweet candidate, handle the tweet\n      for (const tweet of uniqueTweetCandidates) {\n        if (\n          !this.client.lastCheckedTweetId ||\n          BigInt(tweet.id) > this.client.lastCheckedTweetId\n        ) {\n          // Generate the tweetId UUID the same way it's done in handleTweet\n          const tweetId = stringToUuid(tweet.id + '-' + this.runtime.agentId);\n\n          // Check if we've already processed this tweet\n          const existingResponse =\n            await this.runtime.messageManager.getMemoryById(tweetId);\n\n          if (existingResponse) {\n            elizaLogger.log(`Already responded to tweet ${tweet.id}, skipping`);\n            continue;\n          }\n          elizaLogger.log('New Tweet found', tweet.permanentUrl);\n\n          const roomId = stringToUuid(\n            tweet.conversationId + '-' + this.runtime.agentId,\n          );\n\n          const userIdUUID =\n            tweet.userId === this.client.profile.id\n              ? this.runtime.agentId\n              : stringToUuid(tweet.userId!);\n\n          await this.runtime.ensureConnection(\n            userIdUUID,\n            roomId,\n            tweet.username,\n            tweet.name,\n            'twitter',\n          );\n\n          const thread = await buildConversationThread(tweet, this.client);\n\n          const message = {\n            content: {\n              text: tweet.text,\n              imageUrls: tweet.photos?.map((photo) => photo.url) || [],\n            },\n            agentId: this.runtime.agentId,\n            userId: userIdUUID,\n            roomId,\n          };\n\n          await this.handleTweet({\n            tweet,\n            message,\n            thread,\n          });\n\n          // Update the last checked tweet ID after processing each tweet\n          this.client.lastCheckedTweetId = BigInt(tweet.id);\n        }\n      }\n\n      // Save the latest checked tweet ID to the file\n      await this.client.cacheLatestCheckedTweetId();\n\n      elizaLogger.log('Finished checking Twitter interactions');\n    } catch (error) {\n      elizaLogger.error('Error handling Twitter interactions:', error);\n    }\n  }\n\n  private async handleTweet({\n    tweet,\n    message,\n    thread,\n  }: {\n    tweet: Tweet;\n    message: Memory;\n    thread: Tweet[];\n  }) {\n    // Only skip if tweet is from self AND not from a target user\n    if (\n      tweet.userId === this.client.profile.id &&\n      !this.client.twitterConfig.TWITTER_TARGET_USERS.includes(tweet.username)\n    ) {\n      return;\n    }\n\n    if (!message.content.text) {\n      elizaLogger.log('Skipping Tweet with no text', tweet.id);\n      return { text: '', action: 'IGNORE' };\n    }\n\n    elizaLogger.log('Processing Tweet: ', tweet.id);\n    const formatTweet = (tweet: Tweet) => {\n      return `  ID: ${tweet.id}\n  From: ${tweet.name} (@${tweet.username})\n  Text: ${tweet.text}`;\n    };\n    const currentPost = formatTweet(tweet);\n\n    const formattedConversation = thread\n      .map(\n        (tweet) => `@${tweet.username} (${new Date(\n          tweet.timestamp * 1000,\n        ).toLocaleString('en-US', {\n          hour: '2-digit',\n          minute: '2-digit',\n          month: 'short',\n          day: 'numeric',\n        })}):\n        ${tweet.text}`,\n      )\n      .join('\\n\\n');\n\n    const imageDescriptionsArray = [];\n    try {\n      for (const photo of tweet.photos) {\n        const description = await this.runtime\n          .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n          .describeImage(photo.url);\n        imageDescriptionsArray.push(description);\n      }\n    } catch (error) {\n      // Handle the error\n      elizaLogger.error('Error Occured during describing image: ', error);\n    }\n\n    let state = await this.runtime.composeState(message, {\n      twitterClient: this.client.twitterClient,\n      twitterUserName: this.client.twitterConfig.TWITTER_USERNAME,\n      currentPost,\n      formattedConversation,\n      imageDescriptions:\n        imageDescriptionsArray.length > 0\n          ? `\\nImages in Tweet:\\n${imageDescriptionsArray\n              .map(\n                (desc, i) =>\n                  `Image ${i + 1}: Title: ${desc.title}\\nDescription: ${desc.description}`,\n              )\n              .join('\\n\\n')}`\n          : '',\n    });\n\n    // check if the tweet exists, save if it doesn't\n    const tweetId = stringToUuid(tweet.id + '-' + this.runtime.agentId);\n    const tweetExists =\n      await this.runtime.messageManager.getMemoryById(tweetId);\n\n    if (!tweetExists) {\n      elizaLogger.log('tweet does not exist, saving');\n      const userIdUUID = stringToUuid(tweet.userId as string);\n      const roomId = stringToUuid(tweet.conversationId);\n\n      const message = {\n        id: tweetId,\n        agentId: this.runtime.agentId,\n        content: {\n          text: tweet.text,\n          url: tweet.permanentUrl,\n          imageUrls: tweet.photos?.map((photo) => photo.url) || [],\n          inReplyTo: tweet.inReplyToStatusId\n            ? stringToUuid(tweet.inReplyToStatusId + '-' + this.runtime.agentId)\n            : undefined,\n        },\n        userId: userIdUUID,\n        roomId,\n        createdAt: tweet.timestamp * 1000,\n      };\n      this.client.saveRequestMessage(message, state);\n    }\n\n    // get usernames into str\n    const validTargetUsersStr =\n      this.client.twitterConfig.TWITTER_TARGET_USERS.join(',');\n\n    const shouldRespondContext = composeContext({\n      state,\n      template:\n        this.runtime.character.templates?.twitterShouldRespondTemplate ||\n        this.runtime.character?.templates?.shouldRespondTemplate ||\n        twitterShouldRespondTemplate(validTargetUsersStr),\n    });\n\n    const shouldRespond = await generateShouldRespond({\n      runtime: this.runtime,\n      context: shouldRespondContext,\n      modelClass: ModelClass.MEDIUM,\n    });\n\n    // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\n    if (shouldRespond !== 'RESPOND') {\n      elizaLogger.log('Not responding to message');\n      return { text: 'Response Decision:', action: shouldRespond };\n    }\n\n    const context = composeContext({\n      state: {\n        ...state,\n        // Convert actionNames array to string\n        actionNames: Array.isArray(state.actionNames)\n          ? state.actionNames.join(', ')\n          : state.actionNames || '',\n        actions: Array.isArray(state.actions)\n          ? state.actions.join('\\n')\n          : state.actions || '',\n        // Ensure character examples are included\n        characterPostExamples: this.runtime.character.messageExamples\n          ? this.runtime.character.messageExamples\n              .map((example) =>\n                example\n                  .map(\n                    (msg) =>\n                      `${msg.user}: ${msg.content.text}${msg.content.action ? ` [Action: ${msg.content.action}]` : ''}`,\n                  )\n                  .join('\\n'),\n              )\n              .join('\\n\\n')\n          : '',\n      },\n      template:\n        this.runtime.character.templates?.twitterMessageHandlerTemplate ||\n        this.runtime.character?.templates?.messageHandlerTemplate ||\n        twitterMessageHandlerTemplate,\n    });\n\n    const response = await generateMessageResponse({\n      runtime: this.runtime,\n      context,\n      modelClass: ModelClass.LARGE,\n    });\n\n    const removeQuotes = (str: string) => str.replace(/^['\"](.*)['\"]$/, '$1');\n\n    const stringId = stringToUuid(tweet.id + '-' + this.runtime.agentId);\n\n    response.inReplyTo = stringId;\n\n    response.text = removeQuotes(response.text);\n\n    if (response.text) {\n      if (this.isDryRun) {\n        elizaLogger.info(\n          `Dry run: Selected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`,\n        );\n      } else {\n        try {\n          const callback: HandlerCallback = async (\n            response: Content,\n            tweetId?: string,\n          ) => {\n            const memories = await sendTweet(\n              this.client,\n              response,\n              message.roomId,\n              this.client.twitterConfig.TWITTER_USERNAME,\n              tweetId || tweet.id,\n            );\n            return memories;\n          };\n\n          const action = this.runtime.actions.find(\n            (a) => a.name === response.action,\n          );\n          const shouldSuppressInitialMessage = action?.suppressInitialMessage;\n\n          let responseMessages = [];\n\n          if (!shouldSuppressInitialMessage) {\n            responseMessages = await callback(response);\n          } else {\n            responseMessages = [\n              {\n                id: stringToUuid(tweet.id + '-' + this.runtime.agentId),\n                userId: this.runtime.agentId,\n                agentId: this.runtime.agentId,\n                content: response,\n                roomId: message.roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: Date.now(),\n              },\n            ];\n          }\n\n          state = (await this.runtime.updateRecentMessageState(state)) as State;\n\n          for (const responseMessage of responseMessages) {\n            if (\n              responseMessage === responseMessages[responseMessages.length - 1]\n            ) {\n              responseMessage.content.action = response.action;\n            } else {\n              responseMessage.content.action = 'CONTINUE';\n            }\n            await this.runtime.messageManager.createMemory(responseMessage);\n          }\n\n          const responseTweetId =\n            responseMessages[responseMessages.length - 1]?.content?.tweetId;\n\n          await this.runtime.processActions(\n            message,\n            responseMessages,\n            state,\n            (response: Content) => {\n              return callback(response, responseTweetId);\n            },\n          );\n\n          const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\n\n          await this.runtime.cacheManager.set(\n            `twitter/tweet_generation_${tweet.id}.txt`,\n            responseInfo,\n          );\n          await wait();\n        } catch (error) {\n          elizaLogger.error(`Error sending response tweet: ${error}`);\n        }\n      }\n    }\n  }\n\n  async buildConversationThread(\n    tweet: Tweet,\n    maxReplies = 10,\n  ): Promise<Tweet[]> {\n    const thread: Tweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: Tweet, depth = 0) {\n      elizaLogger.log('Processing tweet:', {\n        id: currentTweet.id,\n        inReplyToStatusId: currentTweet.inReplyToStatusId,\n        depth: depth,\n      });\n\n      if (!currentTweet) {\n        elizaLogger.log('No current tweet found for thread building');\n        return;\n      }\n\n      if (depth >= maxReplies) {\n        elizaLogger.log('Reached maximum reply depth', depth);\n        return;\n      }\n\n      // Handle memory storage\n      const memory = await this.runtime.messageManager.getMemoryById(\n        stringToUuid(currentTweet.id + '-' + this.runtime.agentId),\n      );\n      if (!memory) {\n        const roomId = stringToUuid(\n          currentTweet.conversationId + '-' + this.runtime.agentId,\n        );\n        const userId = stringToUuid(currentTweet.userId);\n\n        await this.runtime.ensureConnection(\n          userId,\n          roomId,\n          currentTweet.username,\n          currentTweet.name,\n          'twitter',\n        );\n\n        this.runtime.messageManager.createMemory({\n          id: stringToUuid(currentTweet.id + '-' + this.runtime.agentId),\n          agentId: this.runtime.agentId,\n          content: {\n            text: currentTweet.text,\n            source: 'twitter',\n            url: currentTweet.permanentUrl,\n            imageUrls: currentTweet.photos?.map((photo) => photo.url) || [],\n            inReplyTo: currentTweet.inReplyToStatusId\n              ? stringToUuid(\n                  currentTweet.inReplyToStatusId + '-' + this.runtime.agentId,\n                )\n              : undefined,\n          },\n          createdAt: currentTweet.timestamp * 1000,\n          roomId,\n          userId:\n            currentTweet.userId === this.twitterUserId\n              ? this.runtime.agentId\n              : stringToUuid(currentTweet.userId),\n          embedding: getEmbeddingZeroVector(),\n        });\n      }\n\n      if (visited.has(currentTweet.id)) {\n        elizaLogger.log('Already visited tweet:', currentTweet.id);\n        return;\n      }\n\n      visited.add(currentTweet.id);\n      thread.unshift(currentTweet);\n\n      if (currentTweet.inReplyToStatusId) {\n        elizaLogger.log(\n          'Fetching parent tweet:',\n          currentTweet.inReplyToStatusId,\n        );\n        try {\n          const parentTweet = await this.twitterClient.getTweet(\n            currentTweet.inReplyToStatusId,\n          );\n\n          if (parentTweet) {\n            elizaLogger.log('Found parent tweet:', {\n              id: parentTweet.id,\n              text: parentTweet.text?.slice(0, 50),\n            });\n            await processThread(parentTweet, depth + 1);\n          } else {\n            elizaLogger.log(\n              'No parent tweet found for:',\n              currentTweet.inReplyToStatusId,\n            );\n          }\n        } catch (error) {\n          elizaLogger.log('Error fetching parent tweet:', {\n            tweetId: currentTweet.inReplyToStatusId,\n            error,\n          });\n        }\n      } else {\n        elizaLogger.log('Reached end of reply chain at:', currentTweet.id);\n      }\n    }\n\n    // Need to bind this context for the inner function\n    await processThread.bind(this)(tweet, 0);\n\n    return thread;\n  }\n}\n","import type { Tweet } from '@flooz-link/agent-twitter-client';\nimport { getEmbeddingZeroVector } from '@elizaos/core';\nimport type { Content, Memory, UUID } from '@elizaos/core';\nimport { stringToUuid } from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport { elizaLogger } from '@elizaos/core';\nimport type { Media } from '@elizaos/core';\nimport fs from 'fs';\nimport path from 'path';\nimport { MediaData } from './types';\n\nexport const wait = (minTime = 1000, maxTime = 3000) => {\n  const waitTime =\n    Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n  return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport function isNotEmpty(input?: any): boolean {\n  return !isEmpty(input);\n}\n\nexport function isEmpty(input?: any): boolean {\n  return input === undefined || input === null || input === '';\n}\nexport const isValidTweet = (tweet: Tweet): boolean => {\n  // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n  const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n  const atCount = (tweet.text?.match(/@/g) || []).length;\n  const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n  const totalCount = hashtagCount + atCount + dollarSignCount;\n\n  return (\n    hashtagCount <= 1 && atCount <= 2 && dollarSignCount <= 1 && totalCount <= 3\n  );\n};\n\nexport async function buildConversationThread(\n  tweet: Tweet,\n  client: ClientBase,\n  maxReplies = 10,\n): Promise<Tweet[]> {\n  const thread: Tweet[] = [];\n  const visited: Set<string> = new Set();\n\n  async function processThread(currentTweet: Tweet, depth = 0) {\n    elizaLogger.debug('Processing tweet:', {\n      id: currentTweet.id,\n      inReplyToStatusId: currentTweet.inReplyToStatusId,\n      depth: depth,\n    });\n\n    if (!currentTweet) {\n      elizaLogger.debug('No current tweet found for thread building');\n      return;\n    }\n\n    // Stop if we've reached our reply limit\n    if (depth >= maxReplies) {\n      elizaLogger.debug('Reached maximum reply depth', depth);\n      return;\n    }\n\n    // Handle memory storage\n    const memory = await client.runtime.messageManager.getMemoryById(\n      stringToUuid(currentTweet.id + '-' + client.runtime.agentId),\n    );\n    if (!memory) {\n      const roomId = stringToUuid(\n        currentTweet.conversationId + '-' + client.runtime.agentId,\n      );\n      const userId = stringToUuid(currentTweet.userId);\n\n      await client.runtime.ensureConnection(\n        userId,\n        roomId,\n        currentTweet.username,\n        currentTweet.name,\n        'twitter',\n      );\n\n      await client.runtime.messageManager.createMemory({\n        id: stringToUuid(currentTweet.id + '-' + client.runtime.agentId),\n        agentId: client.runtime.agentId,\n        content: {\n          text: currentTweet.text,\n          source: 'twitter',\n          url: currentTweet.permanentUrl,\n          imageUrls: currentTweet.photos.map((p) => p.url) || [],\n          inReplyTo: currentTweet.inReplyToStatusId\n            ? stringToUuid(\n                currentTweet.inReplyToStatusId + '-' + client.runtime.agentId,\n              )\n            : undefined,\n        },\n        createdAt: currentTweet.timestamp * 1000,\n        roomId,\n        userId:\n          currentTweet.userId === client.profile.id\n            ? client.runtime.agentId\n            : stringToUuid(currentTweet.userId),\n        embedding: getEmbeddingZeroVector(),\n      });\n    }\n\n    if (visited.has(currentTweet.id)) {\n      elizaLogger.debug('Already visited tweet:', currentTweet.id);\n      return;\n    }\n\n    visited.add(currentTweet.id);\n    thread.unshift(currentTweet);\n\n    elizaLogger.debug('Current thread state:', {\n      length: thread.length,\n      currentDepth: depth,\n      tweetId: currentTweet.id,\n    });\n\n    // If there's a parent tweet, fetch and process it\n    if (currentTweet.inReplyToStatusId) {\n      elizaLogger.debug(\n        'Fetching parent tweet:',\n        currentTweet.inReplyToStatusId,\n      );\n      try {\n        const parentTweet = await client.twitterClient.getTweet(\n          currentTweet.inReplyToStatusId,\n        );\n\n        if (parentTweet) {\n          elizaLogger.debug('Found parent tweet:', {\n            id: parentTweet.id,\n            text: parentTweet.text?.slice(0, 50),\n          });\n          await processThread(parentTweet, depth + 1);\n        } else {\n          elizaLogger.debug(\n            'No parent tweet found for:',\n            currentTweet.inReplyToStatusId,\n          );\n        }\n      } catch (error) {\n        elizaLogger.error('Error fetching parent tweet:', {\n          tweetId: currentTweet.inReplyToStatusId,\n          error,\n        });\n      }\n    } else {\n      elizaLogger.debug('Reached end of reply chain at:', currentTweet.id);\n    }\n  }\n\n  await processThread(tweet, 0);\n\n  elizaLogger.debug('Final thread built:', {\n    totalTweets: thread.length,\n    tweetIds: thread.map((t) => ({\n      id: t.id,\n      text: t.text?.slice(0, 50),\n    })),\n  });\n\n  return thread;\n}\n\nexport async function fetchMediaData(\n  attachments: Media[],\n): Promise<MediaData[]> {\n  return Promise.all(\n    attachments.map(async (attachment: Media) => {\n      if (/^(http|https):\\/\\//.test(attachment.url)) {\n        // Handle HTTP URLs\n        const response = await fetch(attachment.url);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch file: ${attachment.url}`);\n        }\n        const mediaBuffer = Buffer.from(await response.arrayBuffer());\n        const mediaType = attachment.contentType;\n        return { data: mediaBuffer, mediaType };\n      } else if (fs.existsSync(attachment.url)) {\n        // Handle local file paths\n        const mediaBuffer = await fs.promises.readFile(\n          path.resolve(attachment.url),\n        );\n        const mediaType = attachment.contentType;\n        return { data: mediaBuffer, mediaType };\n      } else {\n        throw new Error(\n          `File not found: ${attachment.url}. Make sure the path is correct.`,\n        );\n      }\n    }),\n  );\n}\n\nexport async function sendTweet(\n  client: ClientBase,\n  content: Content,\n  roomId: UUID,\n  twitterUsername: string,\n  inReplyTo: string,\n): Promise<Memory[]> {\n  const maxTweetLength = client.twitterConfig.MAX_TWEET_LENGTH;\n  const isLongTweet = maxTweetLength > 280;\n\n  const tweetChunks = splitTweetContent(content.text, maxTweetLength);\n  const sentTweets: Tweet[] = [];\n  let previousTweetId = inReplyTo;\n\n  for (const chunk of tweetChunks) {\n    let mediaData = null;\n\n    if (content.attachments && content.attachments.length > 0) {\n      mediaData = await fetchMediaData(content.attachments);\n    }\n\n    const cleanChunk = deduplicateMentions(chunk.trim());\n\n    const result = await client.requestQueue.add(async () =>\n      isLongTweet\n        ? client.twitterClient.sendLongTweet(\n            cleanChunk,\n            previousTweetId,\n            mediaData,\n          )\n        : client.twitterClient.sendTweet(\n            cleanChunk,\n            previousTweetId,\n            mediaData,\n          ),\n    );\n\n    const body = await result.json();\n    const tweetResult = isLongTweet\n      ? body?.data?.notetweet_create?.tweet_results?.result\n      : body?.data?.create_tweet?.tweet_results?.result;\n\n    // if we have a response\n    if (tweetResult) {\n      // Parse the response\n      const finalTweet: Tweet = {\n        id: tweetResult.rest_id,\n        text: tweetResult.legacy.full_text,\n        conversationId: tweetResult.legacy.conversation_id_str,\n        timestamp: new Date(tweetResult.legacy.created_at).getTime() / 1000,\n        userId: tweetResult.legacy.user_id_str,\n        inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n        permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n        hashtags: [],\n        mentions: [],\n        photos: [],\n        thread: [],\n        urls: [],\n        videos: [],\n      };\n      sentTweets.push(finalTweet);\n      previousTweetId = finalTweet.id;\n    } else {\n      elizaLogger.error('Error sending tweet chunk:', {\n        chunk,\n        response: body,\n      });\n    }\n\n    // Wait a bit between tweets to avoid rate limiting issues\n    await wait(1000, 2000);\n  }\n\n  const memories: Memory[] = sentTweets.map((tweet) => ({\n    id: stringToUuid(tweet.id + '-' + client.runtime.agentId),\n    agentId: client.runtime.agentId,\n    userId: client.runtime.agentId,\n    content: {\n      tweetId: tweet.id,\n      text: tweet.text,\n      source: 'twitter',\n      url: tweet.permanentUrl,\n      imageUrls: tweet.photos.map((p) => p.url) || [],\n      inReplyTo: tweet.inReplyToStatusId\n        ? stringToUuid(tweet.inReplyToStatusId + '-' + client.runtime.agentId)\n        : undefined,\n    },\n    roomId,\n    embedding: getEmbeddingZeroVector(),\n    createdAt: tweet.timestamp * 1000,\n  }));\n\n  return memories;\n}\n\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n  const paragraphs = content.split('\\n\\n').map((p) => p.trim());\n  const tweets: string[] = [];\n  let currentTweet = '';\n\n  for (const paragraph of paragraphs) {\n    if (!paragraph) continue;\n\n    if ((currentTweet + '\\n\\n' + paragraph).trim().length <= maxLength) {\n      if (currentTweet) {\n        currentTweet += '\\n\\n' + paragraph;\n      } else {\n        currentTweet = paragraph;\n      }\n    } else {\n      if (currentTweet) {\n        tweets.push(currentTweet.trim());\n      }\n      if (paragraph.length <= maxLength) {\n        currentTweet = paragraph;\n      } else {\n        // Split long paragraph into smaller chunks\n        const chunks = splitParagraph(paragraph, maxLength);\n        tweets.push(...chunks.slice(0, -1));\n        currentTweet = chunks[chunks.length - 1];\n      }\n    }\n  }\n\n  if (currentTweet) {\n    tweets.push(currentTweet.trim());\n  }\n\n  return tweets;\n}\n\nfunction extractUrls(paragraph: string): {\n  textWithPlaceholders: string;\n  placeholderMap: Map<string, string>;\n} {\n  // replace https urls with placeholder\n  const urlRegex = /https?:\\/\\/[^\\s]+/g;\n  const placeholderMap = new Map<string, string>();\n\n  let urlIndex = 0;\n  const textWithPlaceholders = paragraph.replace(urlRegex, (match) => {\n    // twitter url would be considered as 23 characters\n    // <<URL_CONSIDERER_23_1>> is also 23 characters\n    const placeholder = `<<URL_CONSIDERER_23_${urlIndex}>>`; // Placeholder without . ? ! etc\n    placeholderMap.set(placeholder, match);\n    urlIndex++;\n    return placeholder;\n  });\n\n  return { textWithPlaceholders, placeholderMap };\n}\n\nfunction splitSentencesAndWords(text: string, maxLength: number): string[] {\n  // Split by periods, question marks and exclamation marks\n  // Note that URLs in text have been replaced with `<<URL_xxx>>` and won't be split by dots\n  const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];\n  const chunks: string[] = [];\n  let currentChunk = '';\n\n  for (const sentence of sentences) {\n    if ((currentChunk + ' ' + sentence).trim().length <= maxLength) {\n      if (currentChunk) {\n        currentChunk += ' ' + sentence;\n      } else {\n        currentChunk = sentence;\n      }\n    } else {\n      // Can't fit more, push currentChunk to results\n      if (currentChunk) {\n        chunks.push(currentChunk.trim());\n      }\n\n      // If current sentence itself is less than or equal to maxLength\n      if (sentence.length <= maxLength) {\n        currentChunk = sentence;\n      } else {\n        // Need to split sentence by spaces\n        const words = sentence.split(' ');\n        currentChunk = '';\n        for (const word of words) {\n          if ((currentChunk + ' ' + word).trim().length <= maxLength) {\n            if (currentChunk) {\n              currentChunk += ' ' + word;\n            } else {\n              currentChunk = word;\n            }\n          } else {\n            if (currentChunk) {\n              chunks.push(currentChunk.trim());\n            }\n            currentChunk = word;\n          }\n        }\n      }\n    }\n  }\n\n  // Handle remaining content\n  if (currentChunk) {\n    chunks.push(currentChunk.trim());\n  }\n\n  return chunks;\n}\n\nfunction deduplicateMentions(paragraph: string) {\n  // Regex to match mentions at the beginning of the string\n  const mentionRegex = /^@(\\w+)(?:\\s+@(\\w+))*(\\s+|$)/;\n\n  // Find all matches\n  const matches = paragraph.match(mentionRegex);\n\n  if (!matches) {\n    return paragraph; // If no matches, return the original string\n  }\n\n  // Extract mentions from the match groups\n  let mentions = matches.slice(0, 1)[0].trim().split(' ');\n\n  // Deduplicate mentions\n  mentions = [...new Set(mentions)];\n\n  // Reconstruct the string with deduplicated mentions\n  const uniqueMentionsString = mentions.join(' ');\n\n  // Find where the mentions end in the original string\n  const endOfMentions = paragraph.indexOf(matches[0]) + matches[0].length;\n\n  // Construct the result by combining unique mentions with the rest of the string\n  return uniqueMentionsString + ' ' + paragraph.slice(endOfMentions);\n}\n\nfunction restoreUrls(\n  chunks: string[],\n  placeholderMap: Map<string, string>,\n): string[] {\n  return chunks.map((chunk) => {\n    // Replace all <<URL_CONSIDERER_23_>> in chunk back to original URLs using regex\n    return chunk.replace(/<<URL_CONSIDERER_23_(\\d+)>>/g, (match) => {\n      const original = placeholderMap.get(match);\n      return original || match; // Return placeholder if not found (theoretically won't happen)\n    });\n  });\n}\n\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n  // 1) Extract URLs and replace with placeholders\n  const { textWithPlaceholders, placeholderMap } = extractUrls(paragraph);\n\n  // 2) Use first section's logic to split by sentences first, then do secondary split\n  const splittedChunks = splitSentencesAndWords(\n    textWithPlaceholders,\n    maxLength,\n  );\n\n  // 3) Replace placeholders back to original URLs\n  const restoredChunks = restoreUrls(splittedChunks, placeholderMap);\n\n  return restoredChunks;\n}\n","import type { Tweet } from '@flooz-link/agent-twitter-client';\nimport {\n  composeContext,\n  generateText,\n  getEmbeddingZeroVector,\n  type IAgentRuntime,\n  ModelClass,\n  stringToUuid,\n  type TemplateType,\n  type UUID,\n  truncateToCompleteSentence,\n  parseJSONObjectFromText,\n  extractAttributes,\n  cleanJsonResponse,\n} from '@elizaos/core';\nimport { elizaLogger } from '@elizaos/core';\nimport type { ClientBase } from './base.ts';\nimport { postActionResponseFooter } from '@elizaos/core';\nimport { generateTweetActions } from '@elizaos/core';\nimport { type IImageDescriptionService, ServiceType } from '@elizaos/core';\nimport { buildConversationThread, fetchMediaData } from './utils.ts';\nimport { twitterMessageHandlerTemplate } from './interactions.ts';\nimport { DEFAULT_MAX_TWEET_LENGTH } from './environment.ts';\nimport {\n  Client,\n  Events,\n  GatewayIntentBits,\n  TextChannel,\n  Partials,\n} from 'discord.js';\nimport type { State } from '@elizaos/core';\nimport type { ActionResponse } from '@elizaos/core';\nimport { MediaData } from './types.ts';\n\nconst MAX_TIMELINES_TO_FETCH = 15;\n\nconst twitterPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\\\n\\\\n (double spaces) between statements if there are multiple statements in your response.`;\n\nexport const twitterActionTemplate =\n  `\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\n{{bio}}\n{{postDirections}}\n\nGuidelines:\n- ONLY engage with content that DIRECTLY relates to character's core interests\n- Direct mentions are priority IF they are on-topic\n- Skip ALL content that is:\n  - Off-topic or tangentially related\n  - From high-profile accounts unless explicitly relevant\n  - Generic/viral content without specific relevance\n  - Political/controversial unless central to character\n  - Promotional/marketing unless directly relevant\n\nActions (respond only with tags):\n[LIKE] - Perfect topic match AND aligns with character (9.8/10)\n[RETWEET] - Exceptional content that embodies character's expertise (9.5/10)\n[QUOTE] - Can add substantial domain expertise (9.5/10)\n[REPLY] - Can contribute meaningful, expert-level insight (9.5/10)\n\nTweet:\n{{currentTweet}}\n\n# Respond with qualifying action tags only. Default to NO action unless extremely confident of relevance.` +\n  postActionResponseFooter;\n\ninterface PendingTweet {\n  tweetTextForPosting: string;\n  roomId: UUID;\n  rawTweetContent: string;\n  discordMessageId: string;\n  channelId: string;\n  timestamp: number;\n}\n\ntype PendingTweetApprovalStatus = 'PENDING' | 'APPROVED' | 'REJECTED';\n\nexport class TwitterPostClient {\n  client: ClientBase;\n  runtime: IAgentRuntime;\n  twitterUsername: string;\n  private isProcessing = false;\n  private lastProcessTime = 0;\n  private stopProcessingActions = false;\n  private isDryRun: boolean;\n  private discordClientForApproval: Client;\n  private approvalRequired = false;\n  private discordApprovalChannelId: string;\n  private approvalCheckInterval: number;\n\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.runtime = runtime;\n    this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n    this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n\n    // Log configuration on initialization\n    elizaLogger.log('Twitter Client Configuration:');\n    elizaLogger.log(`- Username: ${this.twitterUsername}`);\n    elizaLogger.log(\n      `- Dry Run Mode: ${this.isDryRun ? 'enabled' : 'disabled'}`,\n    );\n\n    elizaLogger.log(\n      `- Enable Post: ${this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION ? 'enabled' : 'disabled'}`,\n    );\n\n    elizaLogger.log(\n      `- Post Interval: ${this.client.twitterConfig.POST_INTERVAL_MIN}-${this.client.twitterConfig.POST_INTERVAL_MAX} minutes`,\n    );\n    elizaLogger.log(\n      `- Action Processing: ${\n        this.client.twitterConfig.ENABLE_ACTION_PROCESSING\n          ? 'enabled'\n          : 'disabled'\n      }`,\n    );\n    elizaLogger.log(\n      `- Action Interval: ${this.client.twitterConfig.ACTION_INTERVAL} minutes`,\n    );\n    elizaLogger.log(\n      `- Post Immediately: ${\n        this.client.twitterConfig.POST_IMMEDIATELY ? 'enabled' : 'disabled'\n      }`,\n    );\n    elizaLogger.log(\n      `- Search Enabled: ${\n        this.client.twitterConfig.TWITTER_SEARCH_ENABLE ? 'enabled' : 'disabled'\n      }`,\n    );\n\n    const targetUsers = this.client.twitterConfig.TWITTER_TARGET_USERS;\n    if (targetUsers) {\n      elizaLogger.log(`- Target Users: ${targetUsers}`);\n    }\n\n    if (this.isDryRun) {\n      elizaLogger.log(\n        'Twitter client initialized in dry run mode - no actual tweets should be posted',\n      );\n    }\n\n    // Initialize Discord webhook\n    const approvalRequired: boolean =\n      this.runtime\n        .getSetting('TWITTER_APPROVAL_ENABLED')\n        ?.toLocaleLowerCase() === 'true';\n    if (approvalRequired) {\n      const discordToken = this.runtime.getSetting(\n        'TWITTER_APPROVAL_DISCORD_BOT_TOKEN',\n      );\n      const approvalChannelId = this.runtime.getSetting(\n        'TWITTER_APPROVAL_DISCORD_CHANNEL_ID',\n      );\n\n      const APPROVAL_CHECK_INTERVAL =\n        Number.parseInt(\n          this.runtime.getSetting('TWITTER_APPROVAL_CHECK_INTERVAL'),\n        ) || 5 * 60 * 1000; // 5 minutes\n\n      this.approvalCheckInterval = APPROVAL_CHECK_INTERVAL;\n\n      if (!discordToken || !approvalChannelId) {\n        throw new Error(\n          'TWITTER_APPROVAL_DISCORD_BOT_TOKEN and TWITTER_APPROVAL_DISCORD_CHANNEL_ID are required for approval workflow',\n        );\n      }\n\n      this.approvalRequired = true;\n      this.discordApprovalChannelId = approvalChannelId;\n\n      // Set up Discord client event handlers\n      this.setupDiscordClient();\n    }\n  }\n\n  private setupDiscordClient() {\n    this.discordClientForApproval = new Client({\n      intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent,\n        GatewayIntentBits.GuildMessageReactions,\n      ],\n      partials: [Partials.Channel, Partials.Message, Partials.Reaction],\n    });\n    this.discordClientForApproval.once(Events.ClientReady, (readyClient) => {\n      elizaLogger.log(`Discord bot is ready as ${readyClient.user.tag}!`);\n\n      // Generate invite link with required permissions\n      const invite = `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user.id}&permissions=274877991936&scope=bot`;\n      // 274877991936 includes permissions for:\n      // - Send Messages\n      // - Read Messages/View Channels\n      // - Read Message History\n\n      elizaLogger.log(\n        `Use this link to properly invite the Twitter Post Approval Discord bot: ${invite}`,\n      );\n    });\n    // Login to Discord\n    this.discordClientForApproval.login(\n      this.runtime.getSetting('TWITTER_APPROVAL_DISCORD_BOT_TOKEN'),\n    );\n  }\n\n  async start() {\n    if (!this.client.profile) {\n      await this.client.init();\n    }\n\n    const generateNewTweetLoop = async () => {\n      const lastPost = await this.runtime.cacheManager.get<{\n        timestamp: number;\n      }>('twitter/' + this.twitterUsername + '/lastPost');\n\n      const lastPostTimestamp = lastPost?.timestamp ?? 0;\n      const minMinutes = this.client.twitterConfig.POST_INTERVAL_MIN;\n      const maxMinutes = this.client.twitterConfig.POST_INTERVAL_MAX;\n      const randomMinutes =\n        Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) + minMinutes;\n      const delay = randomMinutes * 60 * 1000;\n\n      if (Date.now() > lastPostTimestamp + delay) {\n        await this.generateNewTweet();\n      }\n\n      setTimeout(() => {\n        generateNewTweetLoop(); // Set up next iteration\n      }, delay);\n\n      elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\n    };\n\n    const processActionsLoop = async () => {\n      const actionInterval = this.client.twitterConfig.ACTION_INTERVAL; // Defaults to 5 minutes\n\n      while (!this.stopProcessingActions) {\n        try {\n          const results = await this.processTweetActions();\n          if (results) {\n            elizaLogger.log(`Processed ${results.length} tweets`);\n            elizaLogger.log(\n              `Next action processing scheduled in ${actionInterval} minutes`,\n            );\n            // Wait for the full interval before next processing\n            await new Promise(\n              (resolve) => setTimeout(resolve, actionInterval * 60 * 1000), // now in minutes\n            );\n          }\n        } catch (error) {\n          elizaLogger.error('Error in action processing loop:', error);\n          // Add exponential backoff on error\n          await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error\n        }\n      }\n    };\n\n    if (this.client.twitterConfig.POST_IMMEDIATELY) {\n      await this.generateNewTweet();\n    }\n\n    if (this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION) {\n      generateNewTweetLoop();\n      elizaLogger.log('Tweet generation loop started');\n    }\n\n    if (this.client.twitterConfig.ENABLE_ACTION_PROCESSING) {\n      processActionsLoop().catch((error) => {\n        elizaLogger.error('Fatal error in process actions loop:', error);\n      });\n    }\n\n    // Start the pending tweet check loop if enabled\n    if (this.approvalRequired) this.runPendingTweetCheckLoop();\n  }\n\n  private runPendingTweetCheckLoop() {\n    setInterval(async () => {\n      await this.handlePendingTweet();\n    }, this.approvalCheckInterval);\n  }\n\n  createTweetObject(\n    tweetResult: any,\n    client: any,\n    twitterUsername: string,\n  ): Tweet {\n    return {\n      id: tweetResult.rest_id,\n      name: client.profile.screenName,\n      username: client.profile.username,\n      text: tweetResult.legacy.full_text,\n      conversationId: tweetResult.legacy.conversation_id_str,\n      createdAt: tweetResult.legacy.created_at,\n      timestamp: new Date(tweetResult.legacy.created_at).getTime(),\n      userId: client.profile.id,\n      inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n      permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n      hashtags: [],\n      mentions: [],\n      photos: [],\n      thread: [],\n      urls: [],\n      videos: [],\n    } as Tweet;\n  }\n\n  async processAndCacheTweet(\n    runtime: IAgentRuntime,\n    client: ClientBase,\n    tweet: Tweet,\n    roomId: UUID,\n    rawTweetContent: string,\n  ) {\n    // Cache the last post details\n    await runtime.cacheManager.set(\n      `twitter/${client.profile.username}/lastPost`,\n      {\n        id: tweet.id,\n        timestamp: Date.now(),\n      },\n    );\n\n    // Cache the tweet\n    await client.cacheTweet(tweet);\n\n    // Log the posted tweet\n    elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n    // Ensure the room and participant exist\n    await runtime.ensureRoomExists(roomId);\n    await runtime.ensureParticipantInRoom(runtime.agentId, roomId);\n\n    // Create a memory for the tweet\n    await runtime.messageManager.createMemory({\n      id: stringToUuid(tweet.id + '-' + runtime.agentId),\n      userId: runtime.agentId,\n      agentId: runtime.agentId,\n      content: {\n        text: rawTweetContent.trim(),\n        url: tweet.permanentUrl,\n        source: 'twitter',\n      },\n      roomId,\n      embedding: getEmbeddingZeroVector(),\n      createdAt: tweet.timestamp,\n    });\n  }\n\n  async handleNoteTweet(\n    client: ClientBase,\n    content: string,\n    tweetId?: string,\n    mediaData?: MediaData[],\n  ) {\n    try {\n      const noteTweetResult = await client.requestQueue.add(\n        async () =>\n          await client.twitterClient.sendNoteTweet(content, tweetId, mediaData),\n      );\n\n      if (noteTweetResult.errors && noteTweetResult.errors.length > 0) {\n        // Note Tweet failed due to authorization. Falling back to standard Tweet.\n        const truncateContent = truncateToCompleteSentence(\n          content,\n          this.client.twitterConfig.MAX_TWEET_LENGTH,\n        );\n        return await this.sendStandardTweet(client, truncateContent, tweetId);\n      } else {\n        return noteTweetResult.data.notetweet_create.tweet_results.result;\n      }\n    } catch (error) {\n      throw new Error(`Note Tweet failed: ${error}`);\n    }\n  }\n\n  async sendStandardTweet(\n    client: ClientBase,\n    content: string,\n    tweetId?: string,\n    mediaData?: MediaData[],\n  ) {\n    try {\n      const standardTweetResult = await client.requestQueue.add(\n        async () =>\n          await client.twitterClient.sendTweet(content, tweetId, mediaData),\n      );\n      const body = await standardTweetResult.json();\n      if (!body?.data?.create_tweet?.tweet_results?.result) {\n        elizaLogger.error('Error sending tweet; Bad response:', body);\n        return;\n      }\n      return body.data.create_tweet.tweet_results.result;\n    } catch (error) {\n      elizaLogger.error('Error sending standard Tweet:', error);\n      throw error;\n    }\n  }\n\n  async postTweet(\n    runtime: IAgentRuntime,\n    client: ClientBase,\n    tweetTextForPosting: string,\n    roomId: UUID,\n    rawTweetContent: string,\n    twitterUsername: string,\n    mediaData?: MediaData[],\n  ) {\n    try {\n      elizaLogger.log(`Posting new tweet:\\n`);\n\n      let result;\n\n      if (tweetTextForPosting.length > DEFAULT_MAX_TWEET_LENGTH) {\n        result = await this.handleNoteTweet(\n          client,\n          tweetTextForPosting,\n          undefined,\n          mediaData,\n        );\n      } else {\n        result = await this.sendStandardTweet(\n          client,\n          tweetTextForPosting,\n          undefined,\n          mediaData,\n        );\n      }\n\n      const tweet = this.createTweetObject(result, client, twitterUsername);\n\n      await this.processAndCacheTweet(\n        runtime,\n        client,\n        tweet,\n        roomId,\n        rawTweetContent,\n      );\n    } catch (error) {\n      elizaLogger.error('Error sending tweet:', error);\n    }\n  }\n\n  /**\n   * Generates and posts a new tweet. If isDryRun is true, only logs what would have been posted.\n   */\n  async generateNewTweet() {\n    elizaLogger.log('Generating new tweet');\n\n    try {\n      const roomId = stringToUuid(\n        'twitter_generate_room-' + this.client.profile.username,\n      );\n      await this.runtime.ensureUserExists(\n        this.runtime.agentId,\n        this.client.profile.username,\n        this.runtime.character.name,\n        'twitter',\n      );\n\n      const topics = this.runtime.character.topics.join(', ');\n      const maxTweetLength = this.client.twitterConfig.MAX_TWEET_LENGTH;\n      const state = await this.runtime.composeState(\n        {\n          userId: this.runtime.agentId,\n          roomId: roomId,\n          agentId: this.runtime.agentId,\n          content: {\n            text: topics || '',\n            action: 'TWEET',\n          },\n        },\n        {\n          twitterUserName: this.client.profile.username,\n          maxTweetLength,\n        },\n      );\n\n      const context = composeContext({\n        state,\n        template:\n          this.runtime.character.templates?.twitterPostTemplate ||\n          twitterPostTemplate,\n      });\n\n      elizaLogger.debug('generate post prompt:\\n' + context);\n\n      const response = await generateText({\n        runtime: this.runtime,\n        context,\n        modelClass: ModelClass.SMALL,\n      });\n\n      const rawTweetContent = cleanJsonResponse(response);\n\n      // First attempt to clean content\n      let tweetTextForPosting = null;\n      let mediaData = null;\n\n      // Try parsing as JSON first\n      const parsedResponse = parseJSONObjectFromText(rawTweetContent);\n      if (parsedResponse?.text) {\n        tweetTextForPosting = parsedResponse.text;\n      } else {\n        // If not JSON, use the raw text directly\n        tweetTextForPosting = rawTweetContent.trim();\n      }\n\n      if (\n        parsedResponse?.attachments &&\n        parsedResponse?.attachments.length > 0\n      ) {\n        mediaData = await fetchMediaData(parsedResponse.attachments);\n      }\n\n      // Try extracting text attribute\n      if (!tweetTextForPosting) {\n        const parsingText = extractAttributes(rawTweetContent, ['text']).text;\n        if (parsingText) {\n          tweetTextForPosting = truncateToCompleteSentence(\n            extractAttributes(rawTweetContent, ['text']).text,\n            this.client.twitterConfig.MAX_TWEET_LENGTH,\n          );\n        }\n      }\n\n      // Use the raw text\n      if (!tweetTextForPosting) {\n        tweetTextForPosting = rawTweetContent;\n      }\n\n      // Truncate the content to the maximum tweet length specified in the environment settings, ensuring the truncation respects sentence boundaries.\n      if (maxTweetLength) {\n        tweetTextForPosting = truncateToCompleteSentence(\n          tweetTextForPosting,\n          maxTweetLength,\n        );\n      }\n\n      const removeQuotes = (str: string) => str.replace(/^['\"](.*)['\"]$/, '$1');\n\n      const fixNewLines = (str: string) => str.replaceAll(/\\\\n/g, '\\n\\n'); //ensures double spaces\n\n      // Final cleaning\n      tweetTextForPosting = removeQuotes(fixNewLines(tweetTextForPosting));\n\n      if (this.isDryRun) {\n        elizaLogger.info(\n          `Dry run: would have posted tweet: ${tweetTextForPosting}`,\n        );\n        return;\n      }\n\n      try {\n        if (this.approvalRequired) {\n          // Send for approval instead of posting directly\n          elizaLogger.log(\n            `Sending Tweet For Approval:\\n ${tweetTextForPosting}`,\n          );\n          await this.sendForApproval(\n            tweetTextForPosting,\n            roomId,\n            rawTweetContent,\n          );\n          elizaLogger.log('Tweet sent for approval');\n        } else {\n          elizaLogger.log(`Posting new tweet:\\n ${tweetTextForPosting}`);\n          this.postTweet(\n            this.runtime,\n            this.client,\n            tweetTextForPosting,\n            roomId,\n            rawTweetContent,\n            this.twitterUsername,\n            mediaData,\n          );\n        }\n      } catch (error) {\n        elizaLogger.error('Error sending tweet:', error);\n      }\n    } catch (error) {\n      elizaLogger.error('Error generating new tweet:', error);\n    }\n  }\n\n  private async generateTweetContent(\n    tweetState: any,\n    options?: {\n      template?: TemplateType;\n      context?: string;\n    },\n  ): Promise<string> {\n    const context = composeContext({\n      state: tweetState,\n      template:\n        options?.template ||\n        this.runtime.character.templates?.twitterPostTemplate ||\n        twitterPostTemplate,\n    });\n\n    const response = await generateText({\n      runtime: this.runtime,\n      context: options?.context || context,\n      modelClass: ModelClass.SMALL,\n    });\n\n    elizaLogger.log('generate tweet content response:\\n' + response);\n\n    // First clean up any markdown and newlines\n    const cleanedResponse = cleanJsonResponse(response);\n\n    // Try to parse as JSON first\n    const jsonResponse = parseJSONObjectFromText(cleanedResponse);\n    if (jsonResponse.text) {\n      const truncateContent = truncateToCompleteSentence(\n        jsonResponse.text,\n        this.client.twitterConfig.MAX_TWEET_LENGTH,\n      );\n      return truncateContent;\n    }\n    if (typeof jsonResponse === 'object') {\n      const possibleContent =\n        jsonResponse.content || jsonResponse.message || jsonResponse.response;\n      if (possibleContent) {\n        const truncateContent = truncateToCompleteSentence(\n          possibleContent,\n          this.client.twitterConfig.MAX_TWEET_LENGTH,\n        );\n        return truncateContent;\n      }\n    }\n\n    let truncateContent = null;\n    // Try extracting text attribute\n    const parsingText = extractAttributes(cleanedResponse, ['text']).text;\n    if (parsingText) {\n      truncateContent = truncateToCompleteSentence(\n        parsingText,\n        this.client.twitterConfig.MAX_TWEET_LENGTH,\n      );\n    }\n\n    if (!truncateContent) {\n      // If not JSON or no valid content found, clean the raw text\n      truncateContent = truncateToCompleteSentence(\n        cleanedResponse,\n        this.client.twitterConfig.MAX_TWEET_LENGTH,\n      );\n    }\n\n    return truncateContent;\n  }\n\n  /**\n   * Processes tweet actions (likes, retweets, quotes, replies). If isDryRun is true,\n   * only simulates and logs actions without making API calls.\n   */\n  private async processTweetActions() {\n    if (this.isProcessing) {\n      elizaLogger.log('Already processing tweet actions, skipping');\n      return null;\n    }\n\n    try {\n      this.isProcessing = true;\n      this.lastProcessTime = Date.now();\n\n      elizaLogger.log('Processing tweet actions');\n\n      await this.runtime.ensureUserExists(\n        this.runtime.agentId,\n        this.twitterUsername,\n        this.runtime.character.name,\n        'twitter',\n      );\n\n      const timelines = await this.client.fetchTimelineForActions(\n        MAX_TIMELINES_TO_FETCH,\n      );\n      const maxActionsProcessing =\n        this.client.twitterConfig.MAX_ACTIONS_PROCESSING;\n      const processedTimelines = [];\n\n      for (const tweet of timelines) {\n        try {\n          // Skip if we've already processed this tweet\n          const memory = await this.runtime.messageManager.getMemoryById(\n            stringToUuid(tweet.id + '-' + this.runtime.agentId),\n          );\n          if (memory) {\n            elizaLogger.log(`Already processed tweet ID: ${tweet.id}`);\n            continue;\n          }\n\n          const roomId = stringToUuid(\n            tweet.conversationId + '-' + this.runtime.agentId,\n          );\n\n          const tweetState = await this.runtime.composeState(\n            {\n              userId: this.runtime.agentId,\n              roomId,\n              agentId: this.runtime.agentId,\n              content: { text: '', action: '' },\n            },\n            {\n              twitterUserName: this.twitterUsername,\n              currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\n            },\n          );\n\n          const actionContext = composeContext({\n            state: tweetState,\n            template:\n              this.runtime.character.templates?.twitterActionTemplate ||\n              twitterActionTemplate,\n          });\n\n          const actionResponse = await generateTweetActions({\n            runtime: this.runtime,\n            context: actionContext,\n            modelClass: ModelClass.SMALL,\n          });\n\n          if (!actionResponse) {\n            elizaLogger.log(`No valid actions generated for tweet ${tweet.id}`);\n            continue;\n          }\n          processedTimelines.push({\n            tweet: tweet,\n            actionResponse: actionResponse,\n            tweetState: tweetState,\n            roomId: roomId,\n          });\n        } catch (error) {\n          elizaLogger.error(`Error processing tweet ${tweet.id}:`, error);\n          continue;\n        }\n      }\n\n      const sortProcessedTimeline = (arr: typeof processedTimelines) => {\n        return arr.sort((a, b) => {\n          // Count the number of true values in the actionResponse object\n          const countTrue = (obj: typeof a.actionResponse) =>\n            Object.values(obj).filter(Boolean).length;\n\n          const countA = countTrue(a.actionResponse);\n          const countB = countTrue(b.actionResponse);\n\n          // Primary sort by number of true values\n          if (countA !== countB) {\n            return countB - countA;\n          }\n\n          // Secondary sort by the \"like\" property\n          if (a.actionResponse.like !== b.actionResponse.like) {\n            return a.actionResponse.like ? -1 : 1;\n          }\n\n          // Tertiary sort keeps the remaining objects with equal weight\n          return 0;\n        });\n      };\n      // Sort the timeline based on the action decision score,\n      // then slice the results according to the environment variable to limit the number of actions per cycle.\n      const sortedTimelines = sortProcessedTimeline(processedTimelines).slice(\n        0,\n        maxActionsProcessing,\n      );\n\n      return this.processTimelineActions(sortedTimelines); // Return results array to indicate completion\n    } catch (error) {\n      elizaLogger.error('Error in processTweetActions:', error);\n      throw error;\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  /**\n   * Processes a list of timelines by executing the corresponding tweet actions.\n   * Each timeline includes the tweet, action response, tweet state, and room context.\n   * Results are returned for tracking completed actions.\n   *\n   * @param timelines - Array of objects containing tweet details, action responses, and state information.\n   * @returns A promise that resolves to an array of results with details of executed actions.\n   */\n  private async processTimelineActions(\n    timelines: {\n      tweet: Tweet;\n      actionResponse: ActionResponse;\n      tweetState: State;\n      roomId: UUID;\n    }[],\n  ): Promise<\n    {\n      tweetId: string;\n      actionResponse: ActionResponse;\n      executedActions: string[];\n    }[]\n  > {\n    const results = [];\n    for (const timeline of timelines) {\n      const { actionResponse, tweetState, roomId, tweet } = timeline;\n      try {\n        const executedActions: string[] = [];\n        // Execute actions\n        if (actionResponse.like) {\n          if (this.isDryRun) {\n            elizaLogger.info(`Dry run: would have liked tweet ${tweet.id}`);\n            executedActions.push('like (dry run)');\n          } else {\n            try {\n              await this.client.twitterClient.likeTweet(tweet.id);\n              executedActions.push('like');\n              elizaLogger.log(`Liked tweet ${tweet.id}`);\n            } catch (error) {\n              elizaLogger.error(`Error liking tweet ${tweet.id}:`, error);\n            }\n          }\n        }\n\n        if (actionResponse.retweet) {\n          if (this.isDryRun) {\n            elizaLogger.info(`Dry run: would have retweeted tweet ${tweet.id}`);\n            executedActions.push('retweet (dry run)');\n          } else {\n            try {\n              await this.client.twitterClient.retweet(tweet.id);\n              executedActions.push('retweet');\n              elizaLogger.log(`Retweeted tweet ${tweet.id}`);\n            } catch (error) {\n              elizaLogger.error(`Error retweeting tweet ${tweet.id}:`, error);\n            }\n          }\n        }\n\n        if (actionResponse.quote) {\n          try {\n            // Build conversation thread for context\n            const thread = await buildConversationThread(tweet, this.client);\n            const formattedConversation = thread\n              .map(\n                (t) =>\n                  `@${t.username} (${new Date(\n                    t.timestamp * 1000,\n                  ).toLocaleString()}): ${t.text}`,\n              )\n              .join('\\n\\n');\n\n            // Generate image descriptions if present\n            const imageDescriptions = [];\n            if (tweet.photos?.length > 0) {\n              elizaLogger.log('Processing images in tweet for context');\n              for (const photo of tweet.photos) {\n                const description = await this.runtime\n                  .getService<IImageDescriptionService>(\n                    ServiceType.IMAGE_DESCRIPTION,\n                  )\n                  .describeImage(photo.url);\n                imageDescriptions.push(description);\n              }\n            }\n\n            // Handle quoted tweet if present\n            let quotedContent = '';\n            if (tweet.quotedStatusId) {\n              try {\n                const quotedTweet = await this.client.twitterClient.getTweet(\n                  tweet.quotedStatusId,\n                );\n                if (quotedTweet) {\n                  quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                }\n              } catch (error) {\n                elizaLogger.error('Error fetching quoted tweet:', error);\n              }\n            }\n\n            // Compose rich state with all context\n            const enrichedState = await this.runtime.composeState(\n              {\n                userId: this.runtime.agentId,\n                roomId: stringToUuid(\n                  tweet.conversationId + '-' + this.runtime.agentId,\n                ),\n                agentId: this.runtime.agentId,\n                content: {\n                  text: tweet.text,\n                  action: 'QUOTE',\n                },\n              },\n              {\n                twitterUserName: this.twitterUsername,\n                currentPost: `From @${tweet.username}: ${tweet.text}`,\n                formattedConversation,\n                imageContext:\n                  imageDescriptions.length > 0\n                    ? `\\nImages in Tweet:\\n${imageDescriptions\n                        .map((desc, i) => `Image ${i + 1}: ${desc}`)\n                        .join('\\n')}`\n                    : '',\n                quotedContent,\n              },\n            );\n\n            const quoteContent = await this.generateTweetContent(\n              enrichedState,\n              {\n                template:\n                  this.runtime.character.templates\n                    ?.twitterMessageHandlerTemplate ||\n                  twitterMessageHandlerTemplate,\n              },\n            );\n\n            if (!quoteContent) {\n              elizaLogger.error('Failed to generate valid quote tweet content');\n              return;\n            }\n\n            elizaLogger.log('Generated quote tweet content:', quoteContent);\n            // Check for dry run mode\n            if (this.isDryRun) {\n              elizaLogger.info(\n                `Dry run: A quote tweet for tweet ID ${tweet.id} would have been posted with the following content: \"${quoteContent}\".`,\n              );\n              executedActions.push('quote (dry run)');\n            } else {\n              // Send the tweet through request queue\n              const result = await this.client.requestQueue.add(\n                async () =>\n                  await this.client.twitterClient.sendQuoteTweet(\n                    quoteContent,\n                    tweet.id,\n                  ),\n              );\n\n              const body = await result.json();\n\n              if (body?.data?.create_tweet?.tweet_results?.result) {\n                elizaLogger.log('Successfully posted quote tweet');\n                executedActions.push('quote');\n\n                // Cache generation context for debugging\n                await this.runtime.cacheManager.set(\n                  `twitter/quote_generation_${tweet.id}.txt`,\n                  `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent}`,\n                );\n              } else {\n                elizaLogger.error('Quote tweet creation failed:', body);\n              }\n            }\n          } catch (error) {\n            elizaLogger.error('Error in quote tweet generation:', error);\n          }\n        }\n\n        if (actionResponse.reply) {\n          try {\n            await this.handleTextOnlyReply(tweet, tweetState, executedActions);\n          } catch (error) {\n            elizaLogger.error(`Error replying to tweet ${tweet.id}:`, error);\n          }\n        }\n\n        // Add these checks before creating memory\n        await this.runtime.ensureRoomExists(roomId);\n        await this.runtime.ensureUserExists(\n          stringToUuid(tweet.userId),\n          tweet.username,\n          tweet.name,\n          'twitter',\n        );\n        await this.runtime.ensureParticipantInRoom(\n          this.runtime.agentId,\n          roomId,\n        );\n\n        if (!this.isDryRun) {\n          // Then create the memory\n          await this.runtime.messageManager.createMemory({\n            id: stringToUuid(tweet.id + '-' + this.runtime.agentId),\n            userId: stringToUuid(tweet.userId),\n            content: {\n              text: tweet.text,\n              url: tweet.permanentUrl,\n              source: 'twitter',\n              action: executedActions.join(','),\n            },\n            agentId: this.runtime.agentId,\n            roomId,\n            embedding: getEmbeddingZeroVector(),\n            createdAt: tweet.timestamp * 1000,\n          });\n        }\n\n        results.push({\n          tweetId: tweet.id,\n          actionResponse: actionResponse,\n          executedActions,\n        });\n      } catch (error) {\n        elizaLogger.error(`Error processing tweet ${tweet.id}:`, error);\n        continue;\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Handles text-only replies to tweets. If isDryRun is true, only logs what would\n   * have been replied without making API calls.\n   */\n  private async handleTextOnlyReply(\n    tweet: Tweet,\n    tweetState: any,\n    executedActions: string[],\n  ) {\n    try {\n      // Build conversation thread for context\n      const thread = await buildConversationThread(tweet, this.client);\n      const formattedConversation = thread\n        .map(\n          (t) =>\n            `@${t.username} (${new Date(\n              t.timestamp * 1000,\n            ).toLocaleString()}): ${t.text}`,\n        )\n        .join('\\n\\n');\n\n      // Generate image descriptions if present\n      const imageDescriptions = [];\n      if (tweet.photos?.length > 0) {\n        elizaLogger.log('Processing images in tweet for context');\n        for (const photo of tweet.photos) {\n          const description = await this.runtime\n            .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n            .describeImage(photo.url);\n          imageDescriptions.push(description);\n        }\n      }\n\n      // Handle quoted tweet if present\n      let quotedContent = '';\n      if (tweet.quotedStatusId) {\n        try {\n          const quotedTweet = await this.client.twitterClient.getTweet(\n            tweet.quotedStatusId,\n          );\n          if (quotedTweet) {\n            quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n          }\n        } catch (error) {\n          elizaLogger.error('Error fetching quoted tweet:', error);\n        }\n      }\n\n      // Compose rich state with all context\n      const enrichedState = await this.runtime.composeState(\n        {\n          userId: this.runtime.agentId,\n          roomId: stringToUuid(\n            tweet.conversationId + '-' + this.runtime.agentId,\n          ),\n          agentId: this.runtime.agentId,\n          content: { text: tweet.text, action: '' },\n        },\n        {\n          twitterUserName: this.twitterUsername,\n          currentPost: `From @${tweet.username}: ${tweet.text}`,\n          formattedConversation,\n          imageContext:\n            imageDescriptions.length > 0\n              ? `\\nImages in Tweet:\\n${imageDescriptions\n                  .map((desc, i) => `Image ${i + 1}: ${desc}`)\n                  .join('\\n')}`\n              : '',\n          quotedContent,\n        },\n      );\n\n      // Generate and clean the reply content\n      const replyText = await this.generateTweetContent(enrichedState, {\n        template:\n          this.runtime.character.templates?.twitterMessageHandlerTemplate ||\n          twitterMessageHandlerTemplate,\n      });\n\n      if (!replyText) {\n        elizaLogger.error('Failed to generate valid reply content');\n        return;\n      }\n\n      if (this.isDryRun) {\n        elizaLogger.info(\n          `Dry run: reply to tweet ${tweet.id} would have been: ${replyText}`,\n        );\n        executedActions.push('reply (dry run)');\n        return;\n      }\n\n      elizaLogger.debug('Final reply text to be sent:', replyText);\n\n      let result;\n\n      if (replyText.length > DEFAULT_MAX_TWEET_LENGTH) {\n        result = await this.handleNoteTweet(this.client, replyText, tweet.id);\n      } else {\n        result = await this.sendStandardTweet(this.client, replyText, tweet.id);\n      }\n\n      if (result) {\n        elizaLogger.log('Successfully posted reply tweet');\n        executedActions.push('reply');\n\n        // Cache generation context for debugging\n        await this.runtime.cacheManager.set(\n          `twitter/reply_generation_${tweet.id}.txt`,\n          `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyText}`,\n        );\n      } else {\n        elizaLogger.error('Tweet reply creation failed');\n      }\n    } catch (error) {\n      elizaLogger.error('Error in handleTextOnlyReply:', error);\n    }\n  }\n\n  async stop() {\n    this.stopProcessingActions = true;\n  }\n\n  private async sendForApproval(\n    tweetTextForPosting: string,\n    roomId: UUID,\n    rawTweetContent: string,\n  ): Promise<string | null> {\n    try {\n      const embed = {\n        title: 'New Tweet Pending Approval',\n        description: tweetTextForPosting,\n        fields: [\n          {\n            name: 'Character',\n            value: this.client.profile.username,\n            inline: true,\n          },\n          {\n            name: 'Length',\n            value: tweetTextForPosting.length.toString(),\n            inline: true,\n          },\n        ],\n        footer: {\n          text: \"Reply with '' to post or '' to discard, This will automatically expire and remove after 24 hours if no response received\",\n        },\n        timestamp: new Date().toISOString(),\n      };\n\n      const channel = await this.discordClientForApproval.channels.fetch(\n        this.discordApprovalChannelId,\n      );\n\n      if (!channel || !(channel instanceof TextChannel)) {\n        throw new Error('Invalid approval channel');\n      }\n\n      const message = await channel.send({ embeds: [embed] });\n\n      // Store the pending tweet\n      const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n      const currentPendingTweets =\n        (await this.runtime.cacheManager.get<PendingTweet[]>(\n          pendingTweetsKey,\n        )) || [];\n      // Add new pending tweet\n      currentPendingTweets.push({\n        tweetTextForPosting,\n        roomId,\n        rawTweetContent,\n        discordMessageId: message.id,\n        channelId: this.discordApprovalChannelId,\n        timestamp: Date.now(),\n      });\n\n      // Store updated array\n      await this.runtime.cacheManager.set(\n        pendingTweetsKey,\n        currentPendingTweets,\n      );\n\n      return message.id;\n    } catch (error) {\n      elizaLogger.error('Error Sending Twitter Post Approval Request:', error);\n      return null;\n    }\n  }\n\n  private async checkApprovalStatus(\n    discordMessageId: string,\n  ): Promise<PendingTweetApprovalStatus> {\n    try {\n      // Fetch message and its replies from Discord\n      const channel = await this.discordClientForApproval.channels.fetch(\n        this.discordApprovalChannelId,\n      );\n\n      elizaLogger.log(`channel ${JSON.stringify(channel)}`);\n\n      if (!(channel instanceof TextChannel)) {\n        elizaLogger.error('Invalid approval channel');\n        return 'PENDING';\n      }\n\n      // Fetch the original message and its replies\n      const message = await channel.messages.fetch(discordMessageId);\n\n      // Look for thumbs up reaction ('')\n      const thumbsUpReaction = message.reactions.cache.find(\n        (reaction) => reaction.emoji.name === '',\n      );\n\n      // Look for reject reaction ('')\n      const rejectReaction = message.reactions.cache.find(\n        (reaction) => reaction.emoji.name === '',\n      );\n\n      // Check if the reaction exists and has reactions\n      if (rejectReaction) {\n        const count = rejectReaction.count;\n        if (count > 0) {\n          return 'REJECTED';\n        }\n      }\n\n      // Check if the reaction exists and has reactions\n      if (thumbsUpReaction) {\n        // You might want to check for specific users who can approve\n        // For now, we'll return true if anyone used thumbs up\n        const count = thumbsUpReaction.count;\n        if (count > 0) {\n          return 'APPROVED';\n        }\n      }\n\n      return 'PENDING';\n    } catch (error) {\n      elizaLogger.error('Error checking approval status:', error);\n      return 'PENDING';\n    }\n  }\n\n  private async cleanupPendingTweet(discordMessageId: string) {\n    const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n    const currentPendingTweets =\n      (await this.runtime.cacheManager.get<PendingTweet[]>(pendingTweetsKey)) ||\n      [];\n\n    // Remove the specific tweet\n    const updatedPendingTweets = currentPendingTweets.filter(\n      (tweet) => tweet.discordMessageId !== discordMessageId,\n    );\n\n    if (updatedPendingTweets.length === 0) {\n      await this.runtime.cacheManager.delete(pendingTweetsKey);\n    } else {\n      await this.runtime.cacheManager.set(\n        pendingTweetsKey,\n        updatedPendingTweets,\n      );\n    }\n  }\n\n  private async handlePendingTweet() {\n    elizaLogger.log('Checking Pending Tweets...');\n    const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n    const pendingTweets =\n      (await this.runtime.cacheManager.get<PendingTweet[]>(pendingTweetsKey)) ||\n      [];\n\n    for (const pendingTweet of pendingTweets) {\n      // Check if tweet is older than 24 hours\n      const isExpired =\n        Date.now() - pendingTweet.timestamp > 24 * 60 * 60 * 1000;\n\n      if (isExpired) {\n        elizaLogger.log('Pending tweet expired, cleaning up');\n\n        // Notify on Discord about expiration\n        try {\n          const channel = await this.discordClientForApproval.channels.fetch(\n            pendingTweet.channelId,\n          );\n          if (channel instanceof TextChannel) {\n            const originalMessage = await channel.messages.fetch(\n              pendingTweet.discordMessageId,\n            );\n            await originalMessage.reply(\n              'This tweet approval request has expired (24h timeout).',\n            );\n          }\n        } catch (error) {\n          elizaLogger.error('Error sending expiration notification:', error);\n        }\n\n        await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n        return;\n      }\n\n      // Check approval status\n      elizaLogger.log('Checking approval status...');\n      const approvalStatus: PendingTweetApprovalStatus =\n        await this.checkApprovalStatus(pendingTweet.discordMessageId);\n\n      if (approvalStatus === 'APPROVED') {\n        elizaLogger.log('Tweet Approved, Posting');\n        await this.postTweet(\n          this.runtime,\n          this.client,\n          pendingTweet.tweetTextForPosting,\n          pendingTweet.roomId,\n          pendingTweet.rawTweetContent,\n          this.twitterUsername,\n        );\n\n        // Notify on Discord about posting\n        try {\n          const channel = await this.discordClientForApproval.channels.fetch(\n            pendingTweet.channelId,\n          );\n          if (channel instanceof TextChannel) {\n            const originalMessage = await channel.messages.fetch(\n              pendingTweet.discordMessageId,\n            );\n            await originalMessage.reply(\n              'Tweet has been posted successfully! ',\n            );\n          }\n        } catch (error) {\n          elizaLogger.error('Error sending post notification:', error);\n        }\n\n        await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n      } else if (approvalStatus === 'REJECTED') {\n        elizaLogger.log('Tweet Rejected, Cleaning Up');\n        await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n        // Notify about Rejection of Tweet\n        try {\n          const channel = await this.discordClientForApproval.channels.fetch(\n            pendingTweet.channelId,\n          );\n          if (channel instanceof TextChannel) {\n            const originalMessage = await channel.messages.fetch(\n              pendingTweet.discordMessageId,\n            );\n            await originalMessage.reply('Tweet has been rejected! ');\n          }\n        } catch (error) {\n          elizaLogger.error('Error sending rejection notification:', error);\n        }\n      }\n    }\n  }\n}\n","import { SearchMode } from '@flooz-link/agent-twitter-client';\nimport { composeContext, elizaLogger } from '@elizaos/core';\nimport { generateMessageResponse, generateText } from '@elizaos/core';\nimport { messageCompletionFooter } from '@elizaos/core';\nimport {\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type IImageDescriptionService,\n  ModelClass,\n  ServiceType,\n  type State,\n} from '@elizaos/core';\nimport { stringToUuid } from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport { buildConversationThread, sendTweet, wait } from './utils.ts';\n\nconst twitterSearchTemplate =\n  `{{timeline}}\n\n{{providers}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\nAbout {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{postDirections}}\n\n{{recentPosts}}\n\n# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.\n{{currentPost}}\n\nIMPORTANT: Your response CANNOT be longer than 20 words.\nAim for 1-2 short sentences maximum. Be concise and direct.\n\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.\n\n` + messageCompletionFooter;\n\nexport class TwitterSearchClient {\n  client: ClientBase;\n  runtime: IAgentRuntime;\n  twitterUsername: string;\n  private respondedTweets: Set<string> = new Set();\n\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.runtime = runtime;\n    this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n  }\n\n  async start() {\n    this.engageWithSearchTermsLoop();\n  }\n\n  private engageWithSearchTermsLoop() {\n    this.engageWithSearchTerms().then();\n    const randomMinutes = Math.floor(Math.random() * (120 - 60 + 1)) + 60;\n    elizaLogger.log(\n      `Next twitter search scheduled in ${randomMinutes} minutes`,\n    );\n    setTimeout(\n      () => this.engageWithSearchTermsLoop(),\n      randomMinutes * 60 * 1000,\n    );\n  }\n\n  private async engageWithSearchTerms() {\n    elizaLogger.log('Engaging with search terms');\n    try {\n      const searchTerm = [...this.runtime.character.topics][\n        Math.floor(Math.random() * this.runtime.character.topics.length)\n      ];\n\n      elizaLogger.log('Fetching search tweets');\n      // TODO: we wait 5 seconds here to avoid getting rate limited on startup, but we should queue\n      await new Promise((resolve) => setTimeout(resolve, 5000));\n      const recentTweets = await this.client.fetchSearchTweets(\n        searchTerm,\n        20,\n        SearchMode.Top,\n      );\n      elizaLogger.log('Search tweets fetched');\n\n      const homeTimeline = await this.client.fetchHomeTimeline(50);\n\n      await this.client.cacheTimeline(homeTimeline);\n\n      const formattedHomeTimeline =\n        `# ${this.runtime.character.name}'s Home Timeline\\n\\n` +\n        homeTimeline\n          .map((tweet) => {\n            return `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : ''}\\nText: ${tweet.text}\\n---\\n`;\n          })\n          .join('\\n');\n\n      // randomly slice .tweets down to 20\n      const slicedTweets = recentTweets.tweets\n        .sort(() => Math.random() - 0.5)\n        .slice(0, 20);\n\n      if (slicedTweets.length === 0) {\n        elizaLogger.log(\n          'No valid tweets found for the search term',\n          searchTerm,\n        );\n        return;\n      }\n\n      const prompt = `\n  Here are some tweets related to the search term \"${searchTerm}\":\n\n  ${[...slicedTweets, ...homeTimeline]\n    .filter((tweet) => {\n      // ignore tweets where any of the thread tweets contain a tweet by the bot\n      const thread = tweet.thread;\n      const botTweet = thread.find((t) => t.username === this.twitterUsername);\n      return !botTweet;\n    })\n    .map(\n      (tweet) => `\n    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : ''}\n    From: ${tweet.name} (@${tweet.username})\n    Text: ${tweet.text}\n  `,\n    )\n    .join('\\n')}\n\n  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.\n  Notes:\n    - Respond to English tweets only\n    - Respond to tweets that don't have a lot of hashtags, links, URLs or images\n    - Respond to tweets that are not retweets\n    - Respond to tweets where there is an easy exchange of ideas to have with the user\n    - ONLY respond with the ID of the tweet`;\n\n      const mostInterestingTweetResponse = await generateText({\n        runtime: this.runtime,\n        context: prompt,\n        modelClass: ModelClass.SMALL,\n      });\n\n      const tweetId = mostInterestingTweetResponse.trim();\n      const selectedTweet = slicedTweets.find(\n        (tweet) =>\n          tweet.id.toString().includes(tweetId) ||\n          tweetId.includes(tweet.id.toString()),\n      );\n\n      if (!selectedTweet) {\n        elizaLogger.warn('No matching tweet found for the selected ID');\n        elizaLogger.log('Selected tweet ID:', tweetId);\n        return;\n      }\n\n      elizaLogger.log('Selected tweet to reply to:', selectedTweet?.text);\n\n      if (selectedTweet.username === this.twitterUsername) {\n        elizaLogger.log('Skipping tweet from bot itself');\n        return;\n      }\n\n      const conversationId = selectedTweet.conversationId;\n      const roomId = stringToUuid(conversationId + '-' + this.runtime.agentId);\n\n      const userIdUUID = stringToUuid(selectedTweet.userId as string);\n\n      await this.runtime.ensureConnection(\n        userIdUUID,\n        roomId,\n        selectedTweet.username,\n        selectedTweet.name,\n        'twitter',\n      );\n\n      // crawl additional conversation tweets, if there are any\n      await buildConversationThread(selectedTweet, this.client);\n\n      const message = {\n        id: stringToUuid(selectedTweet.id + '-' + this.runtime.agentId),\n        agentId: this.runtime.agentId,\n        content: {\n          text: selectedTweet.text,\n          url: selectedTweet.permanentUrl,\n          inReplyTo: selectedTweet.inReplyToStatusId\n            ? stringToUuid(\n                selectedTweet.inReplyToStatusId + '-' + this.runtime.agentId,\n              )\n            : undefined,\n        },\n        userId: userIdUUID,\n        roomId,\n        // Timestamps are in seconds, but we need them in milliseconds\n        createdAt: selectedTweet.timestamp * 1000,\n      };\n\n      if (!message.content.text) {\n        elizaLogger.warn('Returning: No response text found');\n        return;\n      }\n\n      // Fetch replies and retweets\n      const replies = selectedTweet.thread;\n      const replyContext = replies\n        .filter((reply) => reply.username !== this.twitterUsername)\n        .map((reply) => `@${reply.username}: ${reply.text}`)\n        .join('\\n');\n\n      let tweetBackground = '';\n      if (selectedTweet.isRetweet) {\n        const originalTweet = await this.client.requestQueue.add(() =>\n          this.client.twitterClient.getTweet(selectedTweet.id),\n        );\n        tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;\n      }\n\n      // Generate image descriptions using GPT-4 vision API\n      const imageDescriptions = [];\n      for (const photo of selectedTweet.photos) {\n        const description = await this.runtime\n          .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n          .describeImage(photo.url);\n        imageDescriptions.push(description);\n      }\n\n      let state = await this.runtime.composeState(message, {\n        twitterClient: this.client.twitterClient,\n        twitterUserName: this.twitterUsername,\n        timeline: formattedHomeTimeline,\n        tweetContext: `${tweetBackground}\n\n  Original Post:\n  By @${selectedTweet.username}\n  ${selectedTweet.text}${replyContext.length > 0 && `\\nReplies to original post:\\n${replyContext}`}\n  ${`Original post text: ${selectedTweet.text}`}\n  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(', ')}\\n` : ''}${imageDescriptions.length > 0 ? `\\nImages in Post (Described): ${imageDescriptions.join(', ')}\\n` : ''}\n  `,\n      });\n\n      await this.client.saveRequestMessage(message, state as State);\n\n      const context = composeContext({\n        state,\n        template:\n          this.runtime.character.templates?.twitterSearchTemplate ||\n          twitterSearchTemplate,\n      });\n\n      const responseContent = await generateMessageResponse({\n        runtime: this.runtime,\n        context,\n        modelClass: ModelClass.LARGE,\n      });\n\n      responseContent.inReplyTo = message.id;\n\n      const response = responseContent;\n\n      if (!response.text) {\n        elizaLogger.warn('Returning: No response text found');\n        return;\n      }\n\n      elizaLogger.log(\n        `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`,\n      );\n      try {\n        const callback: HandlerCallback = async (response: Content) => {\n          const memories = await sendTweet(\n            this.client,\n            response,\n            message.roomId,\n            this.twitterUsername,\n            selectedTweet.id,\n          );\n          return memories;\n        };\n\n        const responseMessages = await callback(responseContent);\n\n        state = await this.runtime.updateRecentMessageState(state);\n\n        for (const responseMessage of responseMessages) {\n          await this.runtime.messageManager.createMemory(\n            responseMessage,\n            false,\n          );\n        }\n\n        state = await this.runtime.updateRecentMessageState(state);\n\n        await this.runtime.evaluate(message, state);\n\n        await this.runtime.processActions(\n          message,\n          responseMessages,\n          state,\n          callback,\n        );\n\n        this.respondedTweets.add(selectedTweet.id);\n        const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}\\nAgent's Output:\\n${response.text}`;\n\n        await this.runtime.cacheManager.set(\n          `twitter/tweet_generation_${selectedTweet.id}.txt`,\n          responseInfo,\n        );\n\n        await wait();\n      } catch (error) {\n        console.error(`Error sending response post: ${error}`);\n      }\n    } catch (error) {\n      console.error('Error engaging with search terms:', error);\n    }\n  }\n}\n","import {\n  elizaLogger,\n  type IAgentRuntime,\n  generateText,\n  ModelClass,\n  ServiceType,\n  type ITranscriptionService,\n} from '@elizaos/core';\nimport type { ClientBase } from './base';\nimport {\n  type Scraper,\n  Space,\n  // @ts-ignore\n  type SpaceConfig,\n  RecordToDiskPlugin,\n  IdleMonitorPlugin,\n  // @ts-ignore\n  type SpeakerRequest,\n} from '@flooz-link/agent-twitter-client';\nimport { SttTtsPlugin } from './plugins/SttTtsSpacesPlugin.ts';\nimport { SpaceParticipant } from '@flooz-link/agent-twitter-client';\nimport { isEmpty, isNotEmpty } from './utils.ts';\nimport { FloozTwitterSpaceDecisionOptions } from './types.ts';\n\ninterface CurrentSpeakerState {\n  userId: string;\n  sessionUUID: string;\n  username: string;\n  startTime: number;\n}\n\n/**\n * Generate short filler text via GPT\n */\nasync function generateFiller(\n  runtime: IAgentRuntime,\n  fillerType: string,\n): Promise<string> {\n  try {\n    const context = `\n    # INSTRUCTIONS:\n  You are generating a short filler message for a Twitter Space. The filler type is \"${fillerType}\".\n  Keep it brief, friendly, and relevant. No more than two sentences.\n  Only return the text, no additional formatting.\n\n  ---`;\n    const output = await generateText({\n      runtime,\n      context,\n      modelClass: ModelClass.SMALL,\n    });\n    return output.trim();\n  } catch (err) {\n    elizaLogger.error('[generateFiller] Error generating filler:', err);\n    return '';\n  }\n}\n\n/**\n * Speak a filler message if STT/TTS plugin is available. Sleep a bit after TTS to avoid cutoff.\n */\nasync function speakFiller(\n  runtime: IAgentRuntime,\n  sttTtsPlugin: SttTtsPlugin | undefined,\n  fillerType: string,\n  sleepAfterMs = 3000,\n): Promise<void> {\n  if (!sttTtsPlugin) return;\n  const text = await generateFiller(runtime, fillerType);\n  if (!text) return;\n\n  elizaLogger.log(`[Space] Filler (${fillerType}) => ${text}`);\n  await sttTtsPlugin.speakText(text);\n\n  if (sleepAfterMs > 0) {\n    await new Promise((res) => setTimeout(res, sleepAfterMs));\n  }\n}\n\n/**\n * Generate topic suggestions via GPT if no topics are configured\n */\nasync function generateTopicsIfEmpty(\n  runtime: IAgentRuntime,\n): Promise<string[]> {\n  try {\n    const context = `# INSTRUCTIONS:\nPlease generate 5 short topic ideas for a Twitter Space about technology or random interesting subjects.\nReturn them as a comma-separated list, no additional formatting or numbering.\n\nExample:\n\"AI Advances, Futuristic Gadgets, Space Exploration, Quantum Computing, Digital Ethics\"\n---\n`;\n    const response = await generateText({\n      runtime,\n      context,\n      modelClass: ModelClass.SMALL,\n    });\n    const topics = response\n      .split(',')\n      .map((t) => t.trim())\n      .filter(Boolean);\n    return topics.length ? topics : ['Random Tech Chat', 'AI Thoughts'];\n  } catch (err) {\n    elizaLogger.error('[generateTopicsIfEmpty] GPT error =>', err);\n    return ['Random Tech Chat', 'AI Thoughts'];\n  }\n}\n\n/**\n * Main class: manage a Twitter Space with N speakers max, speaker queue, filler messages, etc.\n */\nexport class TwitterSpaceClient {\n  private runtime: IAgentRuntime;\n  private client: ClientBase;\n  private scraper: Scraper;\n  private isSpaceRunning = false;\n  private currentSpace?: Space;\n  private spaceId?: string;\n  private startedAt?: number;\n  private checkInterval?: NodeJS.Timeout;\n  private lastSpaceEndedAt?: number;\n  private sttTtsPlugin?: SttTtsPlugin;\n\n  /**\n   * We now store an array of active speakers, not just 1\n   */\n  private activeSpeakers: CurrentSpeakerState[] = [];\n  private speakerQueue: SpeakerRequest[] = [];\n\n  private decisionOptions: FloozTwitterSpaceDecisionOptions;\n\n  constructor(client: ClientBase, runtime: IAgentRuntime) {\n    this.client = client;\n    this.scraper = client.twitterClient;\n    this.runtime = runtime;\n\n    const charSpaces: FloozTwitterSpaceDecisionOptions =\n      runtime.character.twitterSpaces || {};\n    this.decisionOptions = {\n      maxSpeakers: charSpaces.maxSpeakers ?? 1,\n      topics: charSpaces.topics ?? [],\n      typicalDurationMinutes: charSpaces.typicalDurationMinutes ?? 30,\n      idleKickTimeoutMs: charSpaces.idleKickTimeoutMs ?? 5 * 60_000,\n      minIntervalBetweenSpacesMinutes:\n        charSpaces.minIntervalBetweenSpacesMinutes ?? 60,\n      businessHoursOnly: charSpaces.businessHoursOnly ?? false,\n      randomChance: charSpaces.randomChance ?? 0.3,\n      enableIdleMonitor: charSpaces.enableIdleMonitor !== false,\n      enableSttTts: charSpaces.enableSttTts !== false,\n      enableRecording: charSpaces.enableRecording !== false,\n      voiceId:\n        charSpaces.voiceId ||\n        runtime.character.settings.voice.model ||\n        'Xb7hH8MSUJpSbSDYk0k2',\n      sttLanguage: charSpaces.sttLanguage || 'en',\n      speakerMaxDurationMs: charSpaces.speakerMaxDurationMs ?? 4 * 60_000,\n      silenceThreshold: charSpaces.silenceThreshold,\n      silenceDetectionWindow: charSpaces.silenceDetectionWindow,\n    };\n  }\n\n  async joinSpace(spaceId: string) {\n    this.spaceId = spaceId;\n    this.isSpaceRunning = true;\n    elizaLogger.log('[Space] Joining a new Twitter Space...');\n\n    try {\n      // this.currentSpace = new Space(this.scraper);\n      this.startedAt = Date.now();\n\n      // Reset states\n      this.activeSpeakers = [];\n      this.speakerQueue = [];\n\n      // Retrieve keys\n      const elevenLabsKey =\n        this.runtime.getSetting('ELEVENLABS_XI_API_KEY') || '';\n\n      const participant = new SpaceParticipant(this.scraper, {\n        spaceId: this.spaceId,\n        debug: false,\n      });\n\n      // 3) Join the Space in listener mode\n      await participant.joinAsListener();\n      console.log('[TestParticipant] HLS URL =>', participant.getHlsUrl());\n\n      // 4) Request the speaker role => returns { sessionUUID }\n      const { sessionUUID } = await participant.requestSpeaker();\n      console.log('[TestParticipant] Requested speaker =>', sessionUUID);\n\n      // 5) Wait for host acceptance with a maximum wait time (e.g., 15 seconds).\n      try {\n        try {\n          await this.waitForApproval(\n            participant,\n            sessionUUID,\n            isNotEmpty(this.decisionOptions?.speakerApprovalWaitTime)\n              ? this.decisionOptions.speakerApprovalWaitTime\n              : 15000,\n          );\n        } catch (error) {\n          elizaLogger.warn(`Speaker request was not approved, error ${error}`);\n          await participant.cancelSpeakerRequest();\n          throw error;\n        }\n\n        // Plugins\n        if (this.decisionOptions.enableRecording) {\n          elizaLogger.log('[Space] Using RecordToDiskPlugin');\n          const recordToDisk = new RecordToDiskPlugin();\n          recordToDisk.init({\n            space: participant,\n          });\n          participant.use(recordToDisk);\n        }\n\n        if (this.decisionOptions.enableSttTts) {\n          elizaLogger.log('[Space] Using SttTtsPlugin');\n          const sttTts = new SttTtsPlugin();\n          sttTts.init({\n            space: participant as unknown as Space,\n            pluginConfig: {\n              runtime: this.runtime,\n              client: this.client,\n              spaceId: this.spaceId,\n              elevenLabsApiKey: elevenLabsKey,\n              voiceId: this.decisionOptions.voiceId,\n              sttLanguage: this.decisionOptions.sttLanguage,\n              transcriptionService:\n                this.client.runtime.getService<ITranscriptionService>(\n                  ServiceType.TRANSCRIPTION,\n                ),\n              silenceThreshold: this.decisionOptions.silenceThreshold,\n              silenceDetectionWindow:\n                this.decisionOptions?.silenceDetectionWindow ?? 400,\n            },\n          });\n          this.sttTtsPlugin = sttTts;\n          participant.use(sttTts, {\n            runtime: this.runtime,\n            client: this.client,\n            spaceId: this.spaceId,\n            elevenLabsApiKey: elevenLabsKey,\n            voiceId: this.decisionOptions.voiceId,\n            sttLanguage: this.decisionOptions.sttLanguage,\n            transcriptionService: this.client.runtime.getService(\n              ServiceType.TRANSCRIPTION,\n            ),\n            silenceThreshold: this.decisionOptions.silenceThreshold,\n          });\n        }\n\n        if (this.decisionOptions.enableIdleMonitor) {\n          elizaLogger.log('[Space] Using IdleMonitorPlugin');\n          participant.use(\n            new IdleMonitorPlugin(\n              this.decisionOptions.idleKickTimeoutMs ?? 60_000,\n              10_000,\n            ),\n          );\n        }\n\n        this.isSpaceRunning = true;\n        // await this.scraper.sendTweet(\n        //   broadcastInfo.share_url.replace('broadcasts', 'spaces'),\n        // );\n\n        // const spaceUrl = broadcastInfo.share_url.replace(\n        //   'broadcasts',\n        //   'spaces',\n        // );\n        // elizaLogger.log(`[Space] Space started => ${spaceUrl}`);\n\n        // Greet\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'WELCOME');\n\n        // Events\n\n        participant.on('idleTimeout', async (info) => {\n          elizaLogger.log(\n            `[Space] idleTimeout => no audio for ${info.idleMs} ms.`,\n          );\n          await speakFiller(\n            this.client.runtime,\n            this.sttTtsPlugin,\n            'IDLE_ENDING',\n          );\n          await this.stopSpace();\n        });\n\n        participant.on('error', (error) => {\n          elizaLogger.error(`Error on client connection ${error}`);\n        });\n\n        process.on('SIGINT', async () => {\n          elizaLogger.log('[Space] SIGINT => stopping space');\n          await speakFiller(this.client.runtime, this.sttTtsPlugin, 'CLOSING');\n          await this.stopSpace();\n          process.exit(0);\n        });\n      } catch (error) {\n        elizaLogger.error('[Space] Error launching Space =>', error);\n        this.isSpaceRunning = false;\n        throw error;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * waitForApproval waits until \"newSpeakerAccepted\" matches our sessionUUID,\n   * then calls becomeSpeaker() or rejects after a given timeout.\n   */\n  private async waitForApproval(\n    participant: SpaceParticipant,\n    sessionUUID: string,\n    timeoutMs = 10000,\n  ): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      let resolved = false;\n\n      const handler = async (evt: { sessionUUID: string }) => {\n        if (evt.sessionUUID === sessionUUID) {\n          resolved = true;\n          participant.off('newSpeakerAccepted', handler);\n          try {\n            await participant.becomeSpeaker();\n            console.log('[TestParticipant] Successfully became speaker!');\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        }\n      };\n\n      // Listen to \"newSpeakerAccepted\" from participant\n      participant.on('newSpeakerAccepted', handler);\n\n      // Timeout to reject if not approved in time\n      setTimeout(() => {\n        if (!resolved) {\n          participant.off('newSpeakerAccepted', handler);\n          reject(\n            new Error(\n              `[TestParticipant] Timed out waiting for speaker approval after ${timeoutMs}ms.`,\n            ),\n          );\n        }\n      }, timeoutMs);\n    });\n  }\n\n  /**\n   * Periodic check to launch or manage space\n   */\n  public async startPeriodicSpaceCheck() {\n    elizaLogger.log('[Space] Starting periodic check routine...');\n\n    // For instance:\n    const intervalMsWhenIdle = 5 * 60_000; // 5 minutes if no Space is running\n    const intervalMsWhenRunning = 5_000; // 5 seconds if a Space IS running\n\n    const routine = async () => {\n      try {\n        if (!this.isSpaceRunning) {\n          const launch = await this.shouldLaunchSpace();\n          if (launch) {\n            const config = await this.generateSpaceConfig();\n            await this.startSpace(config);\n          }\n          // Plan next iteration with a slower pace\n          this.checkInterval = setTimeout(\n            routine,\n            this.isSpaceRunning ? intervalMsWhenRunning : intervalMsWhenIdle,\n          );\n        } else {\n          // Space is running => manage it more frequently\n          await this.manageCurrentSpace();\n          // Plan next iteration with a faster pace\n          this.checkInterval = setTimeout(routine, intervalMsWhenRunning);\n        }\n      } catch (error) {\n        elizaLogger.error('[Space] Error in routine =>', error);\n        // In case of error, still schedule next iteration\n        this.checkInterval = setTimeout(routine, intervalMsWhenIdle);\n      }\n    };\n\n    routine();\n  }\n\n  stopPeriodicCheck() {\n    if (this.checkInterval) {\n      clearTimeout(this.checkInterval);\n      this.checkInterval = undefined;\n    }\n  }\n\n  private async shouldLaunchSpace(): Promise<boolean> {\n    // Random chance\n    const r = Math.random();\n    if (r > (this.decisionOptions.randomChance ?? 0.3)) {\n      elizaLogger.log('[Space] Random check => skip launching');\n      return false;\n    }\n    // Business hours\n    if (this.decisionOptions.businessHoursOnly) {\n      const hour = new Date().getUTCHours();\n      if (hour < 9 || hour >= 17) {\n        elizaLogger.log('[Space] Out of business hours => skip');\n        return false;\n      }\n    }\n    // Interval\n    const now = Date.now();\n    if (this.lastSpaceEndedAt) {\n      const minIntervalMs =\n        (this.decisionOptions.minIntervalBetweenSpacesMinutes ?? 60) * 60_000;\n      if (now - this.lastSpaceEndedAt < minIntervalMs) {\n        elizaLogger.log('[Space] Too soon since last space => skip');\n        return false;\n      }\n    }\n\n    elizaLogger.log('[Space] Deciding to launch a new Space...');\n    return true;\n  }\n\n  private async generateSpaceConfig(): Promise<SpaceConfig> {\n    const topicsLen = this.decisionOptions?.topics?.length ?? 0;\n    if (topicsLen === 0) {\n      const newTopics = await generateTopicsIfEmpty(this.client?.runtime);\n      this.decisionOptions.topics = newTopics;\n    }\n\n    let chosenTopic = 'Random Tech Chat';\n    if (topicsLen > 0) {\n      chosenTopic =\n        this.decisionOptions.topics[Math.floor(Math.random() * topicsLen)];\n    }\n\n    return {\n      mode: 'INTERACTIVE',\n      title: chosenTopic,\n      description: `Discussion about ${chosenTopic}`,\n      languages: ['en'],\n    };\n  }\n\n  public async startSpace(config: SpaceConfig) {\n    elizaLogger.log('[Space] Starting a new Twitter Space...');\n\n    try {\n      this.currentSpace = new Space(this.scraper);\n      this.isSpaceRunning = false;\n      this.spaceId = undefined;\n      this.startedAt = Date.now();\n\n      // Reset states\n      this.activeSpeakers = [];\n      this.speakerQueue = [];\n\n      // Retrieve keys\n      const elevenLabsKey =\n        this.runtime.getSetting('ELEVENLABS_XI_API_KEY') || '';\n\n      const broadcastInfo = await this.currentSpace.initialize(config);\n      this.spaceId = broadcastInfo.room_id;\n      // Plugins\n      if (this.decisionOptions.enableRecording) {\n        elizaLogger.log('[Space] Using RecordToDiskPlugin');\n        this.currentSpace.use(new RecordToDiskPlugin());\n      }\n\n      if (this.decisionOptions.enableSttTts) {\n        elizaLogger.log('[Space] Using SttTtsPlugin');\n        const sttTts = new SttTtsPlugin();\n        this.sttTtsPlugin = sttTts;\n        this.currentSpace.use(sttTts, {\n          runtime: this.runtime,\n          client: this.client,\n          spaceId: this.spaceId,\n          elevenLabsApiKey: elevenLabsKey,\n          voiceId: this.decisionOptions.voiceId,\n          sttLanguage: this.decisionOptions.sttLanguage,\n          transcriptionService:\n            this.client.runtime.getService<ITranscriptionService>(\n              ServiceType.TRANSCRIPTION,\n            ),\n        });\n      }\n\n      if (this.decisionOptions.enableIdleMonitor) {\n        elizaLogger.log('[Space] Using IdleMonitorPlugin');\n        this.currentSpace.use(\n          new IdleMonitorPlugin(\n            this.decisionOptions.idleKickTimeoutMs ?? 60_000,\n            10_000,\n          ),\n        );\n      }\n\n      this.isSpaceRunning = true;\n      await this.scraper.sendTweet(\n        broadcastInfo.share_url.replace('broadcasts', 'spaces'),\n      );\n\n      const spaceUrl = broadcastInfo.share_url.replace('broadcasts', 'spaces');\n      elizaLogger.log(`[Space] Space started => ${spaceUrl}`);\n\n      // Greet\n      await speakFiller(this.client.runtime, this.sttTtsPlugin, 'WELCOME');\n\n      // Events\n      this.currentSpace.on('occupancyUpdate', (update) => {\n        elizaLogger.log(\n          `[Space] Occupancy => ${update.occupancy} participant(s).`,\n        );\n      });\n\n      this.currentSpace.on('speakerRequest', async (req: SpeakerRequest) => {\n        elizaLogger.log(\n          `[Space] Speaker request from @${req.username} (${req.userId}).`,\n        );\n        await this.handleSpeakerRequest(req);\n      });\n\n      this.currentSpace.on('idleTimeout', async (info) => {\n        elizaLogger.log(\n          `[Space] idleTimeout => no audio for ${info.idleMs} ms.`,\n        );\n        await speakFiller(\n          this.client.runtime,\n          this.sttTtsPlugin,\n          'IDLE_ENDING',\n        );\n        await this.stopSpace();\n      });\n\n      process.on('SIGINT', async () => {\n        elizaLogger.log('[Space] SIGINT => stopping space');\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'CLOSING');\n        await this.stopSpace();\n        process.exit(0);\n      });\n    } catch (error) {\n      elizaLogger.error('[Space] Error launching Space =>', error);\n      this.isSpaceRunning = false;\n      throw error;\n    }\n  }\n\n  /**\n   * Periodic management: check durations, remove extras, maybe accept new from queue\n   */\n  private async manageCurrentSpace() {\n    if (!this.spaceId || !this.currentSpace) {\n      return;\n    }\n    try {\n      const audioSpace = await this.scraper.getAudioSpaceById(this.spaceId);\n      const { participants } = audioSpace;\n      const numSpeakers = participants.speakers?.length || 0;\n      const totalListeners = participants.listeners?.length || 0;\n\n      const activeSpeakerLen = this?.activeSpeakers?.length ?? 0;\n      if (activeSpeakerLen === 0) {\n        elizaLogger.log(\n          `No active speakers to manage, hence nothing to manage, returning`,\n        );\n        return;\n      }\n      // 1) Remove any speaker who exceeded speakerMaxDurationMs\n      const maxDur = this.decisionOptions?.speakerMaxDurationMs ?? 240_000;\n      const now = Date.now();\n\n      for (let i = this.activeSpeakers.length - 1; i >= 0; i--) {\n        const speaker = this.activeSpeakers[i];\n        const elapsed = now - (speaker?.startTime ?? now);\n        if (elapsed > maxDur) {\n          elizaLogger.log(\n            `[Space] Speaker @${speaker?.username} exceeded max duration => removing`,\n          );\n          if (isNotEmpty(speaker?.userId)) {\n            await this.removeSpeaker(speaker?.userId);\n            this.activeSpeakers.splice(i, 1);\n            // Possibly speak a short \"SPEAKER_LEFT\" filler\n            await speakFiller(\n              this.client.runtime,\n              this.sttTtsPlugin,\n              'SPEAKER_LEFT',\n            );\n          }\n        }\n      }\n\n      // 2) If we have capacity for new speakers from the queue, accept them\n      await this.acceptSpeakersFromQueueIfNeeded();\n\n      // 3) If somehow more than maxSpeakers are active, remove the extras\n      if (numSpeakers > (this.decisionOptions.maxSpeakers ?? 1)) {\n        elizaLogger.log('[Space] More than maxSpeakers => removing extras...');\n        await this.kickExtraSpeakers(participants.speakers);\n      }\n\n      // 4) Possibly stop the space if empty or time exceeded\n      const elapsedMinutes = (now - (this.startedAt || 0)) / 60000;\n      if (\n        elapsedMinutes > (this.decisionOptions.typicalDurationMinutes ?? 30) ||\n        (numSpeakers === 0 && totalListeners === 0 && elapsedMinutes > 5)\n      ) {\n        elizaLogger.log('[Space] Condition met => stopping the Space...');\n        await speakFiller(\n          this.client.runtime,\n          this.sttTtsPlugin,\n          'CLOSING',\n          4000,\n        );\n        await this.stopSpace();\n      }\n    } catch (error) {\n      elizaLogger.error('[Space] Error in manageCurrentSpace =>', error);\n    }\n  }\n\n  /**\n   * If we have available slots, accept new speakers from the queue\n   */\n  private async acceptSpeakersFromQueueIfNeeded() {\n    // while queue not empty and activeSpeakers < maxSpeakers, accept next\n    const maxNumberOfSpeakersConfigured =\n      this?.decisionOptions?.maxSpeakers ?? 1;\n    const speakerQueueLen = this.speakerQueue?.length ?? 0;\n    const activeSpeakerLen = this.activeSpeakers?.length ?? 0;\n    while (\n      speakerQueueLen > 0 &&\n      activeSpeakerLen < maxNumberOfSpeakersConfigured\n    ) {\n      const nextReq = this.speakerQueue.shift();\n      if (nextReq) {\n        await speakFiller(this.client.runtime, this.sttTtsPlugin, 'PRE_ACCEPT');\n        await this.acceptSpeaker(nextReq);\n      }\n    }\n  }\n\n  private async handleSpeakerRequest(req: SpeakerRequest) {\n    if (isEmpty(this.spaceId) || isEmpty(this.currentSpace)) {\n      return;\n    }\n\n    const audioSpace = await this.scraper.getAudioSpaceById(this.spaceId);\n    const janusSpeakers = audioSpace?.participants?.speakers || [];\n\n    const maxSpeakersConfiguredLen = this.decisionOptions?.maxSpeakers ?? 1;\n    // If we haven't reached maxSpeakers, accept immediately\n    if (janusSpeakers.length < maxSpeakersConfiguredLen) {\n      elizaLogger.log(`[Space] Accepting speaker @${req.username} now`);\n      await speakFiller(this.client.runtime, this.sttTtsPlugin, 'PRE_ACCEPT');\n      await this.acceptSpeaker(req);\n    } else {\n      elizaLogger.log(`[Space] Adding speaker @${req.username} to the queue`);\n      this.speakerQueue.push(req);\n    }\n  }\n\n  private async acceptSpeaker(req: SpeakerRequest) {\n    if (isEmpty(this.currentSpace)) {\n      return;\n    }\n    try {\n      await this.currentSpace?.approveSpeaker(req.userId, req.sessionUUID);\n      this.activeSpeakers.push({\n        userId: req.userId,\n        sessionUUID: req.sessionUUID,\n        username: req.username,\n        startTime: Date.now(),\n      });\n      elizaLogger.log(`[Space] Speaker @${req.username} is now live`);\n    } catch (err) {\n      elizaLogger.error(\n        `[Space] Error approving speaker @${req.username}:`,\n        err,\n      );\n    }\n  }\n\n  private async removeSpeaker(userId?: string) {\n    if (isEmpty(this.currentSpace)) {\n      return;\n    }\n    if (isEmpty(userId)) {\n      return;\n    }\n    try {\n      await this.currentSpace.removeSpeaker(userId);\n      elizaLogger.log(`[Space] Removed speaker userId=${userId}`);\n    } catch (error) {\n      elizaLogger.error(\n        `[Space] Error removing speaker userId=${userId} =>`,\n        error,\n      );\n    }\n  }\n\n  /**\n   * If more than maxSpeakers are found, remove extras\n   * Also update activeSpeakers array\n   */\n  private async kickExtraSpeakers(speakers: any[]) {\n    if (isEmpty(this.currentSpace)) {\n      return;\n    }\n    const speakersLen = speakers?.length ?? 0;\n    if (speakersLen === 0) {\n      return;\n    }\n    const ms = this.decisionOptions?.maxSpeakers ?? 1;\n\n    // sort by who joined first if needed, or just slice\n    const extras = speakers?.slice(ms) ?? [];\n    for (const sp of extras) {\n      elizaLogger.log(`[Space] Removing extra speaker => userId=${sp.user_id}`);\n      await this.removeSpeaker(sp.user_id);\n\n      // remove from activeSpeakers array\n      const idx = this.activeSpeakers.findIndex((s) => s.userId === sp.user_id);\n      if (idx !== -1) {\n        this.activeSpeakers.splice(idx, 1);\n      }\n    }\n  }\n\n  public async stopSpace() {\n    if (isEmpty(this.currentSpace) || isEmpty(this.isSpaceRunning)) {\n      return;\n    }\n    try {\n      elizaLogger.log('[Space] Stopping the current Space...');\n      await this.currentSpace?.stop();\n    } catch (err) {\n      elizaLogger.error('[Space] Error stopping Space =>', err);\n    } finally {\n      this.isSpaceRunning = false;\n      this.spaceId = undefined;\n      this.currentSpace = undefined;\n      this.startedAt = undefined;\n      this.lastSpaceEndedAt = Date.now();\n      this.activeSpeakers = [];\n      this.speakerQueue = [];\n    }\n  }\n}\n","// src/plugins/SttTtsPlugin.ts\n\nimport { spawn } from 'child_process';\nimport {\n  type ITranscriptionService,\n  elizaLogger,\n  stringToUuid,\n  composeContext,\n  getEmbeddingZeroVector,\n  generateMessageResponse,\n  ModelClass,\n  type Content,\n  type IAgentRuntime,\n  type Memory,\n  type Plugin,\n} from '@elizaos/core';\nimport type {\n  Space,\n  JanusClient,\n  AudioDataWithUser,\n} from '@flooz-link/agent-twitter-client';\nimport type { ClientBase } from '../base';\nimport {\n  twitterVoiceHandlerTemplate,\n} from './templates';\nimport { isEmpty } from '../utils';\nimport { PassThrough } from 'stream';\nimport { EventEmitter } from 'events';\nimport OpenAI from 'openai';\n\n// No Web Audio API polyfill needed, using native Node.js capabilities\n\ninterface PluginConfig {\n  runtime: IAgentRuntime;\n  client: ClientBase;\n  spaceId: string;\n  elevenLabsApiKey?: string; // for TTS\n  sttLanguage?: string; // e.g. \"en\" for Whisper\n  silenceThreshold?: number; // amplitude threshold for ignoring silence\n  silenceDetectionWindow?: number; // time to detect silence\n  voiceId?: string; // specify which ElevenLabs voice to use\n  elevenLabsModel?: string; // e.g. \"eleven_monolingual_v1\"\n  chatContext?: Array<{\n    role: 'system' | 'user' | 'assistant';\n    content: string;\n  }>;\n  transcriptionService: ITranscriptionService;\n  grokApiKey?: string; // API key for Grok\n  grokBaseUrl?: string; // Base URL for Grok API\n}\n\nconst VOLUME_WINDOW_SIZE = 100;\n\n/**\n * MVP plugin for speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\n * Approach:\n *   - Collect each speaker's unmuted PCM in a memory buffer (only if above silence threshold)\n *   - On speaker mute -> flush STT -> GPT -> TTS -> push to Janus\n */\nexport class SttTtsPlugin implements Plugin {\n  name = 'SttTtsPlugin';\n  description = 'Speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)';\n  private runtime: IAgentRuntime;\n  private client: ClientBase;\n  private spaceId: string;\n\n  private space?: Space;\n  private janus?: JanusClient;\n\n  private elevenLabsApiKey?: string;\n  private grokApiKey?: string;\n  private grokBaseUrl = 'https://api.x.ai/v1';\n\n  private voiceId = '21m00Tcm4TlvDq8ikWAM';\n  private elevenLabsModel = 'eleven_monolingual_v1';\n  private chatContext: Array<{\n    role: 'system' | 'user' | 'assistant';\n    content: string;\n  }> = [];\n\n  /**\n   * userId => arrayOfChunks (PCM Int16)\n   */\n  private pcmBuffers = new Map<string, Int16Array[]>();\n\n  /**\n   * For ignoring near-silence frames (if amplitude < threshold)\n   */\n  private silenceThreshold = 50;\n\n  /**\n   * Time to wait before detecting silence, defaults to 1 second, i.e. if no one speaks for 1 second then agent checks if it should respond\n   */\n  private silenceDetectionThreshold = 1000;\n\n  // TTS queue for sequentially speaking\n  private ttsQueue: string[] = [];\n  private isSpeaking = false;\n  private isProcessingAudio = false;\n\n  private userSpeakingTimer: NodeJS.Timeout | null = null;\n  private volumeBuffers: Map<string, number[]>;\n  private ttsAbortController: AbortController | null = null;\n\n  private eventEmitter = new EventEmitter();\n  private openai: OpenAI;\n  private transcriptionService: ITranscriptionService;\n\n  private interruptAnalysisBuffer = new Int16Array(1024);\n  private interruptBufferIndex = 0;\n  private lastInterruptCheck = 0;\n\n  private audioBuffer: Int16Array[] = [];\n  private streamingInterval: NodeJS.Timeout | null = null;\n\n  init(params: { space: Space; pluginConfig?: Record<string, any> }): void {\n    elizaLogger.log(\n      '[SttTtsPlugin] init => Space fully ready. Subscribing to events.',\n    );\n\n    this.space = params.space;\n    this.janus = (this.space as any)?.janusClient as JanusClient | undefined;\n\n    const config = params.pluginConfig as PluginConfig;\n    this.runtime = config?.runtime;\n    this.client = config?.client;\n    this.spaceId = config?.spaceId;\n    this.elevenLabsApiKey = config?.elevenLabsApiKey;\n    this.transcriptionService = config.transcriptionService;\n    if (typeof config?.silenceThreshold === 'number') {\n      this.silenceThreshold = config.silenceThreshold;\n    }\n    if (typeof config?.silenceDetectionWindow === 'number') {\n      this.silenceDetectionThreshold = config.silenceDetectionWindow;\n    }\n    if (typeof config?.silenceThreshold)\n      if (config?.voiceId) {\n        this.voiceId = config.voiceId;\n      }\n    if (config?.elevenLabsModel) {\n      this.elevenLabsModel = config.elevenLabsModel;\n    }\n    if (config?.chatContext) {\n      this.chatContext = config.chatContext;\n    }\n    this.grokApiKey =\n      config?.grokApiKey ?? this.runtime.getSetting('GROK_API_KEY');\n    this.grokBaseUrl =\n      config?.grokBaseUrl ??\n      this.runtime.getSetting('GROK_BASE_URL') ??\n      'https://api.x.ai/v1';\n\n    if (isEmpty(this.grokApiKey)) {\n      throw new Error('Grok API key is required');\n    }\n    if (isEmpty(this.grokBaseUrl)) {\n      throw new Error('Grok base URL is required');\n    }\n\n    this.openai = new OpenAI({\n      apiKey: this.grokApiKey,\n      baseURL: this.grokBaseUrl,\n    });\n\n    this.volumeBuffers = new Map<string, number[]>();\n  }\n\n  private async processAudioQueue() {\n    if (this.audioBuffer.length === 0) return;\n    const chunk = this.audioBuffer.shift();\n    if (chunk) {\n      await this.streamToJanus(chunk);\n    }\n    this.checkAndStopStreaming();\n    if (this.audioBuffer.length > 0) {\n      setTimeout(() => this.processAudioQueue(), 200); // Add delay between streams\n    }\n  }\n\n  private checkAndStopStreaming() {\n    if (this.audioBuffer.length === 0) {\n      this.stopStreamingToJanus();\n    }\n  }\n\n  private streamToJanus(chunk: Int16Array) {\n    // Push the audio chunk to Janus\n    if (this.janus && chunk.length > 0) {\n      try {\n        // Default to 48kHz sample rate if not specified\n        const sampleRate = 48000;\n        this.janus.pushLocalAudio(chunk, sampleRate);\n        elizaLogger.debug(`[SttTtsPlugin] Streaming Int16Array chunk to Janus: ${chunk.length} samples`);\n      } catch (error) {\n        elizaLogger.error('[SttTtsPlugin] Error streaming to Janus:', error);\n      }\n    } else {\n      elizaLogger.warn('[SttTtsPlugin] Cannot stream to Janus: janus not initialized or empty chunk');\n    }\n    \n    // Simulate streaming delay to prevent overwhelming the server\n    return new Promise((resolve) => setTimeout(resolve, 200));\n  }\n\n  /**\n   * Adds an audio chunk for a specific user to the processing buffer\n   * \n   * This method provides a public API for external components to add audio data\n   * to the plugin's processing pipeline. While the plugin primarily receives audio\n   * through the handleAudioData method (called by event handlers), this method\n   * allows for direct programmatic addition of audio chunks.\n   * \n   * The audio chunks are stored in the pcmBuffers map, indexed by userId,\n   * and will be processed when silence is detected or the buffer reaches\n   * a sufficient size.\n   * \n   * @param userId - The unique identifier for the user who generated the audio\n   * @param chunk - The audio data as an Int16Array (PCM format)\n   */\n  public addAudioChunk(userId: string, chunk: Int16Array): void {\n    if (!this.pcmBuffers.has(userId)) {\n      this.pcmBuffers.set(userId, []);\n    }\n    this.pcmBuffers.get(userId)?.push(chunk);\n    this.audioBuffer.push(chunk);\n    this.startStreamingToJanus();\n  }\n\n  private startStreamingToJanus() {\n    if (this.streamingInterval) return;\n    this.streamingInterval = setInterval(() => {\n      if (this.audioBuffer.length > 0) {\n        this.processAudioQueue();\n      }\n    }, 200); // Stream every 200ms\n  }\n\n  private stopStreamingToJanus() {\n    if (this.streamingInterval) {\n      clearInterval(this.streamingInterval);\n      this.streamingInterval = null;\n    }\n  }\n\n  /**\n   * Called whenever we receive PCM from a speaker\n   */\n  onAudioData(data: AudioDataWithUser): void {\n    if (this.isProcessingAudio) {\n      return;\n    }\n\n    // Calculate the maximum amplitude in this audio chunk\n    let maxVal = 0;\n    for (let i = 0; i < data.samples.length; i++) {\n      const val = Math.abs(data.samples[i]);\n      if (val > maxVal) maxVal = val;\n    }\n\n    // Initialize or get the volume buffer for this user\n    let volumeBuffer = this.volumeBuffers.get(data.userId);\n    if (!volumeBuffer) {\n      volumeBuffer = [];\n      this.volumeBuffers.set(data.userId, volumeBuffer);\n    }\n\n    // Add the current max amplitude to the volume buffer\n    volumeBuffer.push(maxVal);\n\n    // Keep the buffer at a reasonable size\n    if (volumeBuffer.length > VOLUME_WINDOW_SIZE) {\n      volumeBuffer.shift();\n    }\n\n    // Calculate average and standard deviation to detect voice vs. noise\n    const avgVolume =\n      volumeBuffer.reduce((sum, val) => sum + val, 0) / volumeBuffer.length;\n\n    // Calculate standard deviation\n    const variance =\n      volumeBuffer.reduce((sum, val) => sum + Math.pow(val - avgVolume, 2), 0) /\n      volumeBuffer.length;\n    const stdDev = Math.sqrt(variance);\n\n    // Voice typically has higher variance than background noise\n    const isLikelyVoice = stdDev > 100 && avgVolume > this.silenceThreshold;\n\n    // Skip processing if below threshold or likely not voice\n    if (maxVal < this.silenceThreshold || !isLikelyVoice) {\n      return;\n    }\n\n    if (this.userSpeakingTimer) {\n      clearTimeout(this.userSpeakingTimer);\n    }\n\n    let arr = this.pcmBuffers.get(data.userId);\n    if (!arr) {\n      arr = [];\n      this.pcmBuffers.set(data.userId, arr);\n    }\n    arr.push(data.samples);\n\n    if (!this.isSpeaking) {\n      this.userSpeakingTimer = setTimeout(() => {\n        // Only process if we have enough audio data (prevents processing very short noises)\n        const chunks = this.pcmBuffers.get(data.userId) || [];\n        const totalAudioLength = chunks.reduce(\n          (sum, chunk) => sum + chunk.length,\n          0,\n        );\n\n        // Require at least 0.5 seconds of audio (24000 samples at 48kHz) to process\n        const minSamplesToProcess = 48000 * 0.5;\n\n        if (totalAudioLength < minSamplesToProcess) {\n          elizaLogger.log(\n            '[SttTtsPlugin] Audio too short, skipping processing for user =>',\n            data.userId,\n            `(${totalAudioLength} samples)`,\n          );\n          return;\n        }\n\n        elizaLogger.log(\n          '[SttTtsPlugin] start processing audio for user =>',\n          data.userId,\n        );\n        this.userSpeakingTimer = null;\n        this.processAudio(data.userId).catch((err) =>\n          elizaLogger.error('[SttTtsPlugin] handleSilence error =>', err),\n        );\n      }, this.silenceDetectionThreshold);\n    } else {\n      // Check for interruption - but only if it's likely to be real speech\n      // Apply the same voice detection logic we use for initial processing\n\n      // Get normalized amplitude for this chunk (0-1 scale)\n      const samples = new Int16Array(\n        data.samples.buffer,\n        data.samples.byteOffset,\n        data.samples.length / 4,\n      );\n\n      // Fill analysis buffer\n      samples.forEach((sample) => {\n        this.interruptAnalysisBuffer[this.interruptBufferIndex++] = sample;\n        if (this.interruptBufferIndex >= this.interruptAnalysisBuffer.length) {\n          this.interruptBufferIndex = 0;\n          if (\n            this.enhancedAnalyzeForInterruption(this.interruptAnalysisBuffer)\n          ) {\n            this.ttsAbortController?.abort();\n            this.isSpeaking = false;\n            elizaLogger.log('[SttTtsPlugin] Fast interruption detected');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * On speaker silence => flush STT => GPT => TTS => push to Janus\n   */\n  private async processAudio(userId: string): Promise<void> {\n    // Since the agent is shared in a single Twitter space, we don't need per-user locks\n    // Instead, use a single isProcessingAudio flag for the entire plugin\n    if (this.isProcessingAudio) {\n      elizaLogger.log(\n        '[SttTtsPlugin] Already processing audio, skipping for user:',\n        userId,\n      );\n      return;\n    }\n\n    // Set global processing flag\n    this.isProcessingAudio = true;\n\n    try {\n      elizaLogger.log(\n        '[SttTtsPlugin] Starting audio processing for user:',\n        userId,\n      );\n\n      // Get chunks and clear only this user's buffer\n      const chunks = this.pcmBuffers.get(userId) || [];\n      this.pcmBuffers.delete(userId);\n\n      if (!chunks.length) {\n        elizaLogger.warn('[SttTtsPlugin] No audio chunks for user =>', userId);\n        return;\n      }\n\n      elizaLogger.log(\n        `[SttTtsPlugin] Processing audio for user=${userId}, chunks=${chunks.length}`,\n      );\n\n      // ---- Optimize parallel operations ----\n\n      // 1. Start merging audio buffer (CPU-bound operation)\n      const mergeBufferPromise = this.mergeAudioChunks(chunks);\n\n      // 2. Do any non-dependent work here while CPU is busy with buffer merging\n      // Clean up resources for this user\n      this.volumeBuffers.delete(userId);\n\n      // 3. Wait for buffer merging to complete\n      const merged = await mergeBufferPromise;\n\n      // Log audio properties before processing\n      elizaLogger.debug(\n        `[SttTtsPlugin] Merged audio buffer: length=${merged.length} samples, ` +\n          `estimated duration=${(merged.length / 48000).toFixed(2)}s`,\n      );\n\n      // 4. Optimize audio (downsample if needed)\n      const optimizedPcm = this.maybeDownsampleAudio(merged, 48000, 16000);\n\n      // 5. Convert to WAV format - declare outside try block so it's accessible in catch\n      let wavBuffer: ArrayBuffer;\n      let sttText: string;\n\n      try {\n        // Convert to WAV format\n        wavBuffer = await this.convertPcmToWavInMemory(\n          optimizedPcm,\n          optimizedPcm === merged ? 48000 : 16000,\n        );\n\n        const start = Date.now();\n\n        // 6. Transcribe audio\n        sttText = await this.transcriptionService.transcribe(wavBuffer);\n\n        console.log(`Transcription took: ${Date.now() - start} ms`);\n        elizaLogger.log(`[SttTtsPlugin] Transcription result: \"${sttText}\"`);\n\n        if (isEmpty(sttText?.trim())) {\n          elizaLogger.warn(\n            `[SttTtsPlugin] No speech recognized for user => ${userId}, ` +\n              `audio buffer size: ${wavBuffer.byteLength} bytes, ` +\n              `transcription time: ${Date.now() - start}ms`,\n          );\n          return;\n        }\n\n        elizaLogger.log(\n          `[SttTtsPlugin] STT => user=${userId}, text=\"${sttText}\"`,\n        );\n\n        // 7. Set up direct streaming pipeline from Grok to ElevenLabs to Janus\n        // Create a TTS abort controller for this session\n        this.ttsAbortController = new AbortController();\n        const signal = this.ttsAbortController.signal;\n\n        // Track accumulated text for logging\n        let accumulatedText = '';\n\n        // Buffer for accumulating text until we have enough for natural TTS\n        let ttsBuffer = '';\n\n        // Minimum characters needed for natural speech synthesis\n        const minTtsChunkSize = 30;\n\n        // Flag to track if TTS is currently processing\n        let isTtsProcessing = false;\n\n        // Helper function to determine if text forms a natural break point\n        const isNaturalBreakPoint = (text: string): boolean => {\n          // Enhanced natural break detection with more specific patterns\n          return (\n            /[.!?](\\s|$)/.test(text) || // Strong sentence endings\n            (/[;:](\\s|$)/.test(text) && text.length > 40) || // Medium pauses with sufficient context\n            (/[,](\\s|$)/.test(text) && text.length > 80) // Commas only with substantial context\n          );\n        };\n\n        let progressiveTimeout: NodeJS.Timeout | null = null;\n        const minCharactersForProgressive = 15;\n        const progressiveDelay = 400; // ms\n\n        const processTtsChunk = async () => {\n          if (progressiveTimeout) {\n            clearTimeout(progressiveTimeout);\n            progressiveTimeout = null;\n          }\n\n          const textToProcess = ttsBuffer;\n          ttsBuffer = '';\n\n          const textWithPauses = textToProcess\n            .replace(/([.!?])(\\s|$)/g, '$1<break time=\"0.4s\"/>$2')\n            .replace(/([;:])(\\s|$)/g, '$1<break time=\"0.3s\"/>$2')\n            .replace(/([,])(\\s|$)/g, '$1<break time=\"0.15s\"/>$2');\n\n          isTtsProcessing = true;\n\n          try {\n            await this.streamTtsToJanus(textWithPauses, signal);\n\n            // Immediately process next chunk if buffer has content\n            if (\n              ttsBuffer.length >= minTtsChunkSize ||\n              isNaturalBreakPoint(ttsBuffer)\n            ) {\n              processTtsChunk();\n            }\n          } finally {\n            isTtsProcessing = false;\n          }\n        };\n\n        const processTtsBuffer = async () => {\n          if (ttsBuffer.length === 0 || isTtsProcessing) return;\n\n          // Process immediately if conditions met\n          processTtsChunk();\n        };\n\n        // Set up event listeners for the streaming response\n        this.eventEmitter.once('stream-start', () => {\n          elizaLogger.log('[SttTtsPlugin] Stream started for user:', userId);\n        });\n\n        // Handle each chunk as it comes in from Grok\n        this.eventEmitter.on('stream-chunk', (chunk: string) => {\n          if (typeof chunk !== 'string' || isEmpty(chunk) || signal.aborted)\n            return;\n\n          // Add to accumulated text for logging\n          accumulatedText += chunk;\n\n          // Add to TTS buffer\n          ttsBuffer += chunk;\n\n          // Start progressive timeout on first chunk\n          if (progressiveTimeout === null) {\n            progressiveTimeout = setTimeout(() => {\n              if (ttsBuffer.length >= minCharactersForProgressive) {\n                processTtsChunk();\n              }\n            }, progressiveDelay);\n          }\n\n          // Process TTS when we have enough text or hit a natural break point\n          if (\n            ttsBuffer.length >= minTtsChunkSize ||\n            isNaturalBreakPoint(ttsBuffer)\n          ) {\n            processTtsBuffer();\n          }\n        });\n\n        // Clean up when stream ends\n        this.eventEmitter.once('stream-end', () => {\n          // Process any remaining text in the buffer\n          if (ttsBuffer.length > 0) {\n            processTtsBuffer();\n          }\n\n          elizaLogger.log('[SttTtsPlugin] Stream ended for user:', userId);\n          elizaLogger.log(\n            `[SttTtsPlugin] user=${userId}, complete reply=\"${accumulatedText}\"`,\n          );\n\n          // Remove all stream listeners to prevent memory leaks\n          this.eventEmitter.removeAllListeners('stream-chunk');\n          this.eventEmitter.removeAllListeners('stream-start');\n          this.eventEmitter.removeAllListeners('stream-end');\n        });\n\n        // Start the streaming response from Grok\n        await this.handleUserMessageStreaming(sttText, userId);\n      } catch (error) {\n        // Handle both transcription errors and general errors\n        if (\n          error.name === 'TranscriptionError' ||\n          error.message?.includes('transcription')\n        ) {\n          elizaLogger.error(`[SttTtsPlugin] Transcription error: ${error}`, {\n            userId,\n            audioBufferSize: wavBuffer?.byteLength || 0,\n            sampleRate: optimizedPcm === merged ? 48000 : 16000,\n            error,\n          });\n        } else {\n          elizaLogger.error('[SttTtsPlugin] processAudio error =>', error);\n        }\n      } finally {\n        // Clean up the TTS abort controller\n        if (this.ttsAbortController) {\n          this.ttsAbortController = null;\n        }\n\n        // Release the global processing flag\n        this.isProcessingAudio = false;\n      }\n    } catch (error) {\n      elizaLogger.error('[SttTtsPlugin] processAudio error =>', error);\n    }\n  }\n\n  private async streamTtsToJanus(\n    text: string,\n    signal: AbortSignal,\n  ): Promise<void> {\n    const SAMPLE_RATE = 48000;\n    const FRAME_SIZE = 480; // 10ms at 48kHz\n    const FRAME_DURATION_MS = 10; // Actual playback duration of each frame\n\n    // Create a PassThrough stream for the MP3 data\n    const mp3Stream = new PassThrough();\n\n    // Set up FFmpeg process for streaming conversion\n    const ffmpeg = spawn('ffmpeg', [\n      // Input stream settings\n      '-i',\n      'pipe:0',\n      '-f',\n      'mp3',\n\n      // Performance flags\n      '-threads',\n      '4',\n      '-loglevel',\n      'error',\n      '-nostdin',\n      '-fflags',\n      '+nobuffer',\n      '-flags',\n      '+low_delay',\n      '-probesize',\n      '32',\n      '-analyzeduration',\n      '0',\n\n      // Output settings - PCM audio\n      '-f',\n      's16le',\n      '-ar',\n      SAMPLE_RATE.toString(),\n      '-ac',\n      '1',\n      'pipe:1',\n    ]);\n\n    // Connect MP3 stream to FFmpeg input\n    mp3Stream.pipe(ffmpeg.stdin);\n\n    // Create a buffer to store audio frames\n    const audioBuffer: Int16Array[] = [];\n\n    // Flag to track if processing is complete\n    let processingComplete = false;\n\n    // Start the ElevenLabs API call with streaming response\n    const elevenLabsPromise = this.elevenLabsTtsStreaming(\n      text,\n      mp3Stream,\n      signal,\n    );\n\n    // Process FFmpeg output and store in buffer\n    const processingPromise = new Promise<void>((resolve, reject) => {\n      let pcmBuffer = Buffer.alloc(0);\n\n      ffmpeg.stdout.on('data', (chunk: Buffer) => {\n        try {\n          if (signal.aborted) return;\n\n          // Append new chunk to our buffer\n          pcmBuffer = Buffer.concat([pcmBuffer, chunk]);\n\n          // Process complete frames\n          while (pcmBuffer.length >= FRAME_SIZE * 2) {\n            // 2 bytes per sample\n            // Extract a complete frame\n            const frameBuffer = pcmBuffer.slice(0, FRAME_SIZE * 2);\n            pcmBuffer = pcmBuffer.slice(FRAME_SIZE * 2);\n\n            // Convert to Int16Array and store in audio buffer\n            const frame = new Int16Array(\n              frameBuffer.buffer,\n              frameBuffer.byteOffset,\n              FRAME_SIZE,\n            );\n\n            // Create a copy of the frame to avoid shared buffer issues\n            const frameCopy = new Int16Array(FRAME_SIZE);\n            frameCopy.set(frame);\n\n            // Add to our ordered buffer queue\n            audioBuffer.push(frameCopy);\n          }\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      ffmpeg.stderr.on('data', (data) => {\n        if (data.toString().includes('Error')) {\n          console.error('[FFmpeg Streaming Error]', data.toString().trim());\n        }\n      });\n\n      ffmpeg.on('close', (code) => {\n        try {\n          if (code !== 0 && !signal.aborted) {\n            reject(\n              new Error(`ffmpeg streaming process exited with code ${code}`),\n            );\n            return;\n          }\n\n          // Process any remaining audio in the buffer\n          if (pcmBuffer.length > 0 && !signal.aborted) {\n            // Create a proper sized frame for any remaining data\n            const frameBuffer = Buffer.alloc(FRAME_SIZE * 2);\n            pcmBuffer.copy(\n              frameBuffer,\n              0,\n              0,\n              Math.min(pcmBuffer.length, FRAME_SIZE * 2),\n            );\n\n            const frame = new Int16Array(FRAME_SIZE);\n\n            // Copy from the buffer view to our frame\n            const srcView = new Int16Array(\n              frameBuffer.buffer,\n              frameBuffer.byteOffset,\n              FRAME_SIZE,\n            );\n\n            frame.set(srcView);\n            audioBuffer.push(frame);\n          }\n\n          processingComplete = true;\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      ffmpeg.on('error', (err) => {\n        reject(new Error(`FFmpeg process error: ${err.message}`));\n      });\n    });\n\n    try {\n      // Wait for audio processing to complete (or at least start building the buffer)\n      await Promise.race([\n        processingPromise.catch((err) => {\n          elizaLogger.error('[SttTtsPlugin] Processing error:', err);\n        }),\n        // Also wait for a minimum buffer to build up before starting playback\n        new Promise<void>((resolve) => {\n          const checkBuffer = () => {\n            if (audioBuffer.length > 10 || signal.aborted) {\n              resolve();\n            } else {\n              setTimeout(checkBuffer, 50);\n            }\n          };\n          checkBuffer();\n        }),\n      ]);\n\n      // Stream the audio frames with proper timing\n      let frameIndex = 0;\n      const startTime = Date.now();\n\n      while (\n        (frameIndex < audioBuffer.length || !processingComplete) &&\n        !signal.aborted\n      ) {\n        // If we've played all available frames but processing isn't complete, wait for more\n        if (frameIndex >= audioBuffer.length && !processingComplete) {\n          await new Promise<void>((resolve) => {\n            const waitForMoreFrames = () => {\n              if (\n                frameIndex < audioBuffer.length ||\n                processingComplete ||\n                signal.aborted\n              ) {\n                resolve();\n              } else {\n                setTimeout(waitForMoreFrames, 20);\n              }\n            };\n            waitForMoreFrames();\n          });\n\n          // If we're still out of frames after waiting, exit the loop\n          if (frameIndex >= audioBuffer.length) {\n            break;\n          }\n        }\n\n        // Calculate the ideal playback time for this frame\n        const idealPlaybackTime = startTime + frameIndex * FRAME_DURATION_MS;\n        const currentTime = Date.now();\n\n        // Adjust timing if we're behind or ahead\n        if (currentTime < idealPlaybackTime) {\n          // We're ahead of schedule, wait until the right time\n          await new Promise((r) =>\n            setTimeout(r, idealPlaybackTime - currentTime),\n          );\n        } else if (currentTime > idealPlaybackTime + 100) {\n          // We're significantly behind, skip frames to catch up\n          const framesToSkip = Math.floor(\n            (currentTime - idealPlaybackTime) / FRAME_DURATION_MS,\n          );\n          if (framesToSkip > 0) {\n            elizaLogger.log(\n              `[SttTtsPlugin] Skipping ${framesToSkip} frames to catch up`,\n            );\n            frameIndex += framesToSkip;\n            continue;\n          }\n        }\n\n        // Get the next frame\n        const frame = audioBuffer[frameIndex];\n\n        // Send to Janus\n        try {\n          await this.streamChunkToJanus(frame, SAMPLE_RATE);\n        } catch (error) {\n          elizaLogger.error(\n            '[SttTtsPlugin] Error sending frame to Janus:',\n            error,\n          );\n        }\n\n        frameIndex++;\n      }\n\n      // Wait for any remaining processing to complete\n      await processingPromise;\n      await elevenLabsPromise;\n\n      elizaLogger.log(\n        `[SttTtsPlugin] Audio streaming completed: ${audioBuffer.length} frames played`,\n      );\n    } catch (error) {\n      if (signal.aborted) {\n        elizaLogger.log('[SttTtsPlugin] Audio streaming aborted');\n      } else {\n        elizaLogger.error('[SttTtsPlugin] Audio streaming error:', error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Modified ElevenLabs TTS function that streams the response to a writable stream\n   * instead of waiting for the full response\n   */\n  private async elevenLabsTtsStreaming(\n    text: string,\n    outputStream: NodeJS.WritableStream,\n    signal: AbortSignal,\n  ): Promise<void> {\n    try {\n      if (!this.elevenLabsApiKey) {\n        throw new Error('[SttTtsPlugin] No ElevenLabs API key');\n      }\n\n      // Set up ElevenLabs API request\n      const apiKey = this.elevenLabsApiKey;\n      const voiceId = this.voiceId;\n\n      // Use the streaming endpoint\n      const url = `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}/stream`;\n\n      elizaLogger.log(\n        `[SttTtsPlugin] Starting ElevenLabs streaming TTS request`,\n      );\n\n      // Make the API request\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          Accept: 'audio/mpeg',\n          'Content-Type': 'application/json',\n          'xi-api-key': apiKey,\n        },\n        body: JSON.stringify({\n          text,\n          model_id: this.elevenLabsModel,\n          voice_settings: {\n            stability: 0.4,\n            similarity_boost: 0.8,\n          },\n        }),\n        signal,\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(\n          `ElevenLabs API error: ${response.status} ${response.statusText} - ${errorText}`,\n        );\n      }\n\n      if (!response.body) {\n        throw new Error('Response body is null');\n      }\n\n      elizaLogger.log(\n        `[SttTtsPlugin] ElevenLabs response received, streaming to FFmpeg`,\n      );\n\n      // Stream the response directly to our output stream\n      const reader = response.body.getReader();\n\n      let done = false;\n      let bytesReceived = 0;\n\n      while (!done && !signal.aborted) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n\n        if (value && !signal.aborted) {\n          bytesReceived += value.length;\n\n          // Write chunk to our stream\n          outputStream.write(Buffer.from(value));\n\n          // Log progress periodically\n          if (bytesReceived % 10000 < 1000) {\n            elizaLogger.log(\n              `[SttTtsPlugin] Streaming TTS: ${bytesReceived} bytes received`,\n            );\n          }\n        }\n      }\n\n      // End the stream when done\n      outputStream.end();\n      elizaLogger.log(\n        `[SttTtsPlugin] ElevenLabs streaming completed: ${bytesReceived} total bytes`,\n      );\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        elizaLogger.log('[SttTtsPlugin] ElevenLabs request aborted');\n      } else {\n        elizaLogger.error('[SttTtsPlugin] ElevenLabs streaming error:', error);\n      }\n\n      // Make sure to end the stream on error\n      outputStream.end();\n      throw error;\n    }\n  }\n\n  /**\n   * Stream a single chunk of audio to Janus\n   * Fixed to ensure exact byte length requirement is met\n   */\n  private async streamChunkToJanus(\n    samples: Int16Array,\n    sampleRate: number,\n  ): Promise<void> {\n    // Janus expects exactly 480 samples (960 bytes)\n    const EXPECTED_SAMPLES = 480;\n    const EXPECTED_BYTES = EXPECTED_SAMPLES * 2; // 960 bytes\n\n    return new Promise<void>((resolve, reject) => {\n      try {\n        // Check if we need to create a properly sized buffer\n        if (\n          samples.length !== EXPECTED_SAMPLES ||\n          samples.buffer.byteLength !== EXPECTED_BYTES\n        ) {\n          // Create a new buffer with exactly the right size\n          const properSizedSamples = new Int16Array(EXPECTED_SAMPLES);\n\n          // Copy data from original samples, being careful not to overflow\n          const copySamples = Math.min(samples.length, EXPECTED_SAMPLES);\n          for (let i = 0; i < copySamples; i++) {\n            properSizedSamples[i] = samples[i];\n          }\n\n          // Create a buffer view that's EXACTLY 960 bytes (480 samples)\n          // This is crucial - we need the buffer to be exactly 960 bytes\n          const bufferView = new Int16Array(\n            properSizedSamples.buffer,\n            0,\n            EXPECTED_SAMPLES,\n          );\n\n          // Send the properly sized buffer to Janus\n          this.janus?.pushLocalAudio(bufferView, sampleRate);\n        } else {\n          // The buffer is already the right size\n          this.janus?.pushLocalAudio(samples, sampleRate);\n        }\n\n        resolve();\n      } catch (error) {\n        console.error('[SttTtsPlugin] Error sending audio to Janus:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Helper method to convert audio chunk to Int16Array format required by Janus\n   */\n  private convertAudioChunkToInt16(audioChunk: any): Int16Array {\n    // If already Int16Array, return as is\n    if (audioChunk instanceof Int16Array) {\n      return audioChunk;\n    }\n\n    // If it's a Float32Array (common format from Web Audio API)\n    if (audioChunk instanceof Float32Array) {\n      const int16Chunk = new Int16Array(audioChunk.length);\n      for (let i = 0; i < audioChunk.length; i++) {\n        // Convert from float [-1.0, 1.0] to int16 [-32768, 32767]\n        int16Chunk[i] = Math.max(\n          -32768,\n          Math.min(32767, Math.round(audioChunk[i] * 32767)),\n        );\n      }\n      return int16Chunk;\n    }\n\n    // If it's an ArrayBuffer or other binary format\n    if (audioChunk instanceof ArrayBuffer || ArrayBuffer.isView(audioChunk)) {\n      // Assume it's PCM data that needs to be converted to Int16Array\n      // This may need adjustment based on the actual format from your TTS service\n      return new Int16Array(\n        audioChunk instanceof ArrayBuffer ? audioChunk : audioChunk.buffer,\n      );\n    }\n\n    // Fallback for unknown formats - return empty array\n    elizaLogger.warn(\n      '[SttTtsPlugin] Unknown audio chunk format, returning empty array',\n    );\n    return new Int16Array(0);\n  }\n\n  /**\n   * Downsample audio if needed for Whisper\n   * Whisper works best with 16kHz audio\n   */\n  private maybeDownsampleAudio(\n    audio: Int16Array,\n    originalSampleRate: number,\n    targetSampleRate: number,\n  ): Int16Array {\n    // If already at target rate or downsampling not needed, return original\n    if (originalSampleRate <= targetSampleRate) {\n      return audio;\n    }\n\n    // Calculate the ratio for downsampling\n    const ratio = originalSampleRate / targetSampleRate;\n    const newLength = Math.floor(audio.length / ratio);\n    const result = new Int16Array(newLength);\n\n    // Enhanced downsampling with linear interpolation for better quality\n    // This preserves more of the audio information compared to simple picking\n    for (let i = 0; i < newLength; i++) {\n      const exactPos = i * ratio;\n      const lowIndex = Math.floor(exactPos);\n      const highIndex = Math.min(lowIndex + 1, audio.length - 1);\n      const fraction = exactPos - lowIndex;\n\n      // Linear interpolation between adjacent samples\n      result[i] = Math.round(\n        (1 - fraction) * audio[lowIndex] + fraction * audio[highIndex],\n      );\n    }\n\n    elizaLogger.debug(\n      `[SttTtsPlugin] Downsampled audio from ${originalSampleRate}Hz to ${targetSampleRate}Hz, ` +\n        `original length: ${audio.length}, new length: ${newLength}`,\n    );\n\n    return this.normalizeAudioLevels(result);\n  }\n\n  /**\n   * Normalize audio levels to improve speech recognition\n   * This helps ensure the audio is in an optimal range for the transcription service\n   */\n  private normalizeAudioLevels(audio: Int16Array): Int16Array {\n    // Find the maximum amplitude in the audio\n    let maxAmplitude = 0;\n    for (let i = 0; i < audio.length; i++) {\n      const absValue = Math.abs(audio[i]);\n      if (absValue > maxAmplitude) {\n        maxAmplitude = absValue;\n      }\n    }\n\n    // If the audio is already loud enough, return it as is\n    if (maxAmplitude > 10000) {\n      return audio;\n    }\n\n    // Calculate a scaling factor to normalize the audio\n    // Target around 50-75% of maximum possible amplitude for Int16 (-32768 to 32767)\n    const targetAmplitude = 24000; // ~75% of max Int16 value\n    const scaleFactor = maxAmplitude > 0 ? targetAmplitude / maxAmplitude : 1;\n\n    // Apply the scaling factor to normalize the audio\n    const result = new Int16Array(audio.length);\n    for (let i = 0; i < audio.length; i++) {\n      // Scale and clamp to Int16 range\n      result[i] = Math.max(\n        -32768,\n        Math.min(32767, Math.round(audio[i] * scaleFactor)),\n      );\n    }\n\n    elizaLogger.debug(\n      `[SttTtsPlugin] Normalized audio levels, max amplitude: ${maxAmplitude}, ` +\n        `scale factor: ${scaleFactor.toFixed(2)}`,\n    );\n\n    return result;\n  }\n\n  /**\n   * Convert to WAV format\n   */\n  private async convertPcmToWavInMemory(\n    pcmData: Int16Array,\n    sampleRate: number,\n  ): Promise<ArrayBuffer> {\n    // number of channels\n    const numChannels = 1;\n    // byte rate = (sampleRate * numChannels * bitsPerSample/8)\n    const byteRate = sampleRate * numChannels * 2;\n    const blockAlign = numChannels * 2;\n    // data chunk size = pcmData.length * (bitsPerSample/8)\n    const dataSize = pcmData.length * 2;\n\n    // WAV header is 44 bytes\n    const buffer = new ArrayBuffer(44 + dataSize);\n    const view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    this.writeString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + dataSize, true); // file size - 8\n    this.writeString(view, 8, 'WAVE');\n\n    // fmt sub-chunk\n    this.writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)\n    view.setUint16(20, 1, true); // AudioFormat (1 = PCM)\n    view.setUint16(22, numChannels, true); // NumChannels\n    view.setUint32(24, sampleRate, true); // SampleRate\n    view.setUint32(28, byteRate, true); // ByteRate\n    view.setUint16(32, blockAlign, true); // BlockAlign\n    view.setUint16(34, 16, true); // BitsPerSample (16)\n\n    // data sub-chunk\n    this.writeString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n\n    // Write PCM samples\n    let offset = 44;\n    for (let i = 0; i < pcmData.length; i++, offset += 2) {\n      view.setInt16(offset, pcmData[i], true);\n    }\n\n    // Log WAV buffer details for debugging\n    elizaLogger.debug(\n      `[SttTtsPlugin] Created WAV buffer: size=${buffer.byteLength} bytes, ` +\n        `sample rate=${sampleRate}Hz, channels=${numChannels}, ` +\n        `samples=${pcmData.length}, duration=${(pcmData.length / sampleRate).toFixed(2)}s`,\n    );\n\n    return buffer;\n  }\n\n  /**\n   * Helper method to write a string to a DataView at a specific offset\n   */\n  private writeString(view: DataView, offset: number, string: string): void {\n    for (let i = 0; i < string.length; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  }\n\n  /**\n   * Handle User Message\n   */\n  private async handleUserMessage(\n    userText: string,\n    userId: string, // This is the raw Twitter user ID like 'tw-1865462035586142208'\n  ): Promise<string> {\n    // Extract the numeric ID part\n    const numericId = userId.replace('tw-', '');\n    const roomId = stringToUuid(`twitter_generate_room-${this.spaceId}`);\n\n    // Create consistent UUID for the user\n    const userUuid = stringToUuid(`twitter-user-${numericId}`);\n\n    // Ensure the user exists in the accounts table\n    // Ensure room exists and user is in it\n\n    await Promise.all([\n      this.runtime.ensureUserExists(\n        userUuid,\n        userId, // Use full Twitter ID as username\n        `Twitter User ${numericId}`,\n        'twitter',\n      ),\n      this.runtime.ensureRoomExists(roomId),\n      this.runtime.ensureParticipantInRoom(userUuid, roomId),\n    ]);\n\n    let start = Date.now();\n\n    const memory = {\n      id: stringToUuid(`${roomId}-voice-message-${Date.now()}`),\n      agentId: this.runtime.agentId,\n      content: {\n        text: userText,\n        source: 'twitter',\n      },\n      userId: userUuid,\n      roomId,\n      embedding: getEmbeddingZeroVector(),\n      createdAt: Date.now(),\n    };\n\n    let [state] = await Promise.all([\n      this.runtime.composeState(\n        {\n          agentId: this.runtime.agentId,\n          content: { text: userText, source: 'twitter' },\n          userId: userUuid,\n          roomId,\n        },\n        {\n          twitterUserName: this.client.profile.username,\n          agentName: this.runtime.character.name,\n        },\n      ),\n      this.runtime.messageManager.createMemory(memory),\n    ]);\n    console.log(\n      `Compose state and create memory took ${Date.now() - start} ms`,\n    );\n\n    start = Date.now();\n    state = await this.runtime.updateRecentMessageState(state);\n    console.log(`Recent messages state update took ${Date.now() - start} ms`);\n\n    const shouldIgnore = await this._shouldIgnore(memory);\n\n    if (shouldIgnore) {\n      return '';\n    }\n\n    // const shouldRespond = await this._shouldRespond(userText, state);\n\n    // console.log(`should Respond took ${Date.now() - start} ms`);\n\n    // if (!shouldRespond) {\n    //   return '';\n    // }\n\n    start = Date.now();\n    const context = composeContext({\n      state,\n      template:\n        this.runtime.character.templates?.twitterVoiceHandlerTemplate ||\n        this.runtime.character.templates?.messageHandlerTemplate ||\n        twitterVoiceHandlerTemplate,\n    });\n\n    const responseContent = await this._generateResponse(memory, context);\n\n    console.log(`Generating Response took ${Date.now() - start} ms`);\n\n    const responseMemory: Memory = {\n      id: stringToUuid(`${memory.id}-voice-response-${Date.now()}`),\n      agentId: this.runtime.agentId,\n      userId: this.runtime.agentId,\n      content: {\n        ...responseContent,\n        user: this.runtime.character.name,\n        inReplyTo: memory.id,\n      },\n      roomId,\n      embedding: getEmbeddingZeroVector(),\n    };\n\n    const reply = responseMemory.content.text?.trim();\n    if (reply) {\n      await this.runtime.messageManager.createMemory(responseMemory);\n    }\n\n    this.eventEmitter.emit('response', reply);\n\n    return reply;\n  }\n\n  /**\n   * Handle User Message with streaming support\n   */\n  private async handleUserMessageStreaming(\n    userText: string,\n    userId: string, // This is the raw Twitter user ID like 'tw-1865462035586142208'\n  ): Promise<void> {\n    // Extract the numeric ID part\n    const numericId = userId.replace('tw-', '');\n    const roomId = stringToUuid(`twitter_generate_room-${this.spaceId}`);\n\n    // Create consistent UUID for the user\n    const userUuid = stringToUuid(`twitter-user-${numericId}`);\n\n    // Ensure the user exists in the accounts table\n    // Ensure room exists and user is in it\n    await Promise.all([\n      this.runtime.ensureUserExists(\n        userUuid,\n        userId, // Use full Twitter ID as username\n        `Twitter User ${numericId}`,\n        'twitter',\n      ),\n      this.runtime.ensureRoomExists(roomId),\n      this.runtime.ensureParticipantInRoom(userUuid, roomId),\n    ]).catch((error) => {\n      elizaLogger.warn(\n        `Error when handling streaming for spaces error ${error} ignoring`,\n      );\n      return;\n    });\n\n    const memory = {\n      id: stringToUuid(`${roomId}-voice-message-${Date.now()}`),\n      agentId: this.runtime.agentId,\n      content: {\n        text: userText,\n        source: 'twitter',\n      },\n      userId: userUuid,\n      roomId,\n      embedding: getEmbeddingZeroVector(),\n      createdAt: Date.now(),\n    };\n\n    const [state] = await Promise.all([\n      this.runtime.composeState(\n        {\n          agentId: this.runtime.agentId,\n          content: { text: userText, source: 'twitter' },\n          userId: userUuid,\n          roomId,\n        },\n        {\n          twitterUserName: this.client.profile.username,\n          agentName: this.runtime.character.name,\n        },\n      ),\n      Promise.resolve(),\n      // this.runtime.messageManager.createMemory(memory).catch(error => {\n      //   elizaLogger.warn(`Error when creating memories for twitter spaces ${error} ignoring`);\n      //   return;\n      // }),\n    ]);\n\n    // state = await this.runtime.updateRecentMessageState(state).catch(error => {\n    //   elizaLogger.warn(`Error when updating recent message state from spaces ${error} ignoring`);\n    //   return state;\n    // });\n    const shouldIgnore = await this._shouldIgnore(memory);\n    if (shouldIgnore) {\n      return;\n    }\n\n    // Compose context using the template\n    const context = composeContext({\n      state,\n      template:\n        this.runtime.character.templates?.twitterVoiceHandlerTemplate ||\n        this.runtime.character.templates?.messageHandlerTemplate ||\n        twitterVoiceHandlerTemplate,\n    });\n\n    // Log character information for debugging\n    elizaLogger.log('[SttTtsPlugin] Character info:', {\n      name: this.runtime.character.name,\n      system: this.runtime.character.system,\n    });\n\n    // Create a system message that includes the full context\n    const systemMessage = {\n      role: 'system' as const,\n      content: context,\n    };\n\n    const userMessage = {\n      role: 'user' as const,\n      content: userText,\n    };\n\n    const messages = [...this.chatContext, systemMessage, userMessage];\n\n    // Progressive timeout mechanism\n    const progressiveTimeout: NodeJS.Timeout | null = null;\n    const minCharactersForProgressive = 15;\n    const progressiveDelay = 400; // ms\n\n    // Signal stream start\n    this.eventEmitter.emit('stream-start');\n\n    const start = Date.now();\n    // Make streaming request to Grok\n    const stream = await this.openai.chat.completions.create({\n      model: 'grok-2-latest',\n      messages: messages,\n      stream: true,\n    });\n\n    let fullResponse = '';\n    let jsonBuffer = '';\n    let isJsonResponse = false;\n    let textValue = '';\n\n    // Process each chunk as it arrives\n    for await (const chunk of stream) {\n      const content = chunk.choices[0]?.delta?.content || '';\n      if (!content) continue;\n\n      fullResponse += content;\n\n      // Check early chunks for JSON indicators\n      if (!isJsonResponse && jsonBuffer.length < 30) {\n        jsonBuffer += content;\n        if (\n          jsonBuffer.includes('```json') ||\n          jsonBuffer.includes('```\\njson') ||\n          jsonBuffer.includes('```') ||\n          jsonBuffer.includes('{')\n        ) {\n          isJsonResponse = true;\n        }\n      }\n\n      // If it's not JSON, emit directly\n      if (!isJsonResponse) {\n        console.log(`Time took for emitting ${Date.now() - start}`);\n        this.eventEmitter.emit('stream-chunk', content);\n        continue;\n      }\n\n      // It's JSON, continue buffering\n      jsonBuffer += content;\n\n      // Try to extract the text field value\n      try {\n        // Look for \"text\": pattern\n        const textMatch = /\"text\":\\s*\"([^\"]*)/.exec(jsonBuffer);\n\n        if (textMatch) {\n          // We found the text field\n          const capturedText = textMatch[1];\n\n          // If we have more text than before, emit the difference\n          if (capturedText.length > textValue.length) {\n            const newText = capturedText.substring(textValue.length);\n            console.log(`Time took for emitting ${Date.now() - start}`);\n            this.eventEmitter.emit('stream-chunk', newText);\n            textValue = capturedText;\n          }\n        }\n\n        // Also check for a complete JSON object and parse it\n        if (\n          jsonBuffer.includes('}') &&\n          (jsonBuffer.includes('```') || jsonBuffer.endsWith('}'))\n        ) {\n          // Try to extract the complete JSON\n          let jsonStr = jsonBuffer;\n\n          // Clean up markdown code block syntax if present\n          if (jsonStr.includes('```json')) {\n            jsonStr = jsonStr.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n          } else if (jsonStr.includes('```')) {\n            jsonStr = jsonStr.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n          }\n\n          // Find the first { and last }\n          const firstBrace = jsonStr.indexOf('{');\n          const lastBrace = jsonStr.lastIndexOf('}');\n\n          if (firstBrace >= 0 && lastBrace > firstBrace) {\n            const jsonObject = jsonStr.substring(firstBrace, lastBrace + 1);\n\n            try {\n              const parsed = JSON.parse(jsonObject);\n\n              // If we have a text field, emit any new content\n              if (parsed.text && parsed.text.length > textValue.length) {\n                const newText = parsed.text.substring(textValue.length);\n                console.log(`Time took for emitting ${Date.now() - start}`);\n                this.eventEmitter.emit('stream-chunk', newText);\n                textValue = parsed.text;\n              }\n            } catch (e) {\n              // Incomplete or invalid JSON, continue buffering\n            }\n          }\n        }\n      } catch (e) {\n        // Error in regex or parsing, continue buffering\n      }\n    }\n\n    // If we never found a text field but have JSON, try one last time to parse it\n    if (isJsonResponse && jsonBuffer && !textValue) {\n      try {\n        // Clean up markdown code block syntax if present\n        let jsonStr = jsonBuffer;\n        if (jsonStr.includes('```json')) {\n          jsonStr = jsonStr.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n        } else if (jsonStr.includes('```')) {\n          jsonStr = jsonStr.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n        }\n\n        // Find the first { and last }\n        const firstBrace = jsonStr.indexOf('{');\n        const lastBrace = jsonStr.lastIndexOf('}');\n\n        if (firstBrace >= 0 && lastBrace > firstBrace) {\n          const jsonObject = jsonStr.substring(firstBrace, lastBrace + 1);\n          const parsed = JSON.parse(jsonObject);\n\n          if (parsed.text) {\n            console.log(`Time took for emitting ${Date.now() - start}`);\n            this.eventEmitter.emit('stream-chunk', parsed.text);\n          } else {\n            console.log(`Time took for emitting ${Date.now() - start}`);\n            // No text field found, emit the whole buffer as fallback\n            this.eventEmitter.emit('stream-chunk', jsonBuffer);\n          }\n        } else {\n          console.log(`Time took for emitting ${Date.now() - start}`);\n          // No valid JSON found, emit the whole buffer as fallback\n          this.eventEmitter.emit('stream-chunk', jsonBuffer);\n        }\n      } catch (e) {\n        console.log(`Time took for emitting ${Date.now() - start}`);\n        // Parsing failed, emit the whole buffer as fallback\n        this.eventEmitter.emit('stream-chunk', jsonBuffer);\n      }\n    }\n\n    console.log(`Time took for completing LLM ${Date.now() - start}`);\n    // Signal stream end\n    this.eventEmitter.emit('stream-end');\n\n    // Save the complete response to memory\n    // if (fullResponse.trim()) {\n    //   const responseMemory: Memory = {\n    //     id: stringToUuid(`${memory.id}-voice-response-${Date.now()}`),\n    //     agentId: this.runtime.agentId,\n    //     userId: this.runtime.agentId,\n    //     content: {\n    //       text: fullResponse,\n    //       source: 'twitter',\n    //       user: this.runtime.character.name,\n    //       inReplyTo: memory.id\n    //     },\n    //     roomId,\n    //     embedding: getEmbeddingZeroVector()\n    //   };\n\n    //   await this.runtime.messageManager.createMemory(responseMemory).catch(error => {\n    //     elizaLogger.warn(`Error when creating memory after response on spaces ${error} ignoring`)\n    //     return;\n    //   });\n    // }\n  }\n\n  /**\n   * Generate Response\n   */\n  private async _generateResponse(\n    message: Memory,\n    context: string,\n  ): Promise<Content> {\n    const { userId, roomId } = message;\n\n    const response = await generateMessageResponse({\n      runtime: this.runtime,\n      context,\n      modelClass: ModelClass.SMALL,\n    });\n\n    response.source = 'discord';\n\n    if (!response) {\n      elizaLogger.error(\n        '[SttTtsPlugin] No response from generateMessageResponse',\n      );\n      return;\n    }\n\n    await this.runtime.databaseAdapter.log({\n      body: { message, context, response },\n      userId: userId,\n      roomId,\n      type: 'response',\n    });\n\n    return response;\n  }\n\n  /**\n   * Should Ignore\n   */\n  private async _shouldIgnore(message: Memory): Promise<boolean> {\n    elizaLogger.debug('message.content: ', message.content);\n    // if the message is 3 characters or less, ignore it\n    const messageStr = message?.content?.text;\n    const messageLen = messageStr?.length ?? 0;\n    if (messageLen < 3) {\n      return true;\n    }\n\n    const loseInterestWords = [\n      // telling the bot to stop talking\n      'shut up',\n      'stop',\n      'dont talk',\n      'silence',\n      'stop talking',\n      'be quiet',\n      'hush',\n      'stfu',\n      'stupid bot',\n      'dumb bot',\n\n      // offensive words\n      'fuck',\n      'shit',\n      'damn',\n      'suck',\n      'dick',\n      'cock',\n      'sex',\n      'sexy',\n    ];\n    if (\n      messageLen < 50 &&\n      loseInterestWords.some((word) =>\n        messageStr?.toLowerCase()?.includes(word),\n      )\n    ) {\n      return true;\n    }\n\n    const ignoreWords = ['k', 'ok', 'bye', 'lol', 'nm', 'uh'];\n    if (\n      messageStr?.length < 8 &&\n      ignoreWords.some((word) => messageStr?.toLowerCase()?.includes(word))\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Add a message (system, user or assistant) to the chat context.\n   * E.g. to store conversation history or inject a persona.\n   */\n  public addMessage(role: 'system' | 'user' | 'assistant', content: string) {\n    this.chatContext.push({ role, content });\n    elizaLogger.log(\n      `[SttTtsPlugin] addMessage => role=${role}, content=${content}`,\n    );\n  }\n\n  /**\n   * Clear the chat context if needed.\n   */\n  public clearChatContext() {\n    this.chatContext = [];\n    elizaLogger.log('[SttTtsPlugin] clearChatContext => done');\n  }\n\n  /**\n   * Enhanced analysis for detecting user interruptions in audio\n   * Uses a more sophisticated algorithm to detect speech onset\n   */\n  private enhancedAnalyzeForInterruption(buffer: Int16Array): boolean {\n    // Skip analysis if we're not speaking (no need to detect interruptions)\n    if (!this.isSpeaking) {\n      return false;\n    }\n\n    // Energy threshold for detecting speech\n    const ENERGY_THRESHOLD = 10000;\n\n    // Number of consecutive frames that must exceed the threshold\n    const CONSECUTIVE_FRAMES_THRESHOLD = 5;\n\n    // Frame size for analysis (in samples)\n    const FRAME_SIZE = 160; // 10ms at 16kHz\n\n    // Calculate energy for each frame\n    let consecutiveHighEnergyFrames = 0;\n\n    for (let i = 0; i < buffer.length - FRAME_SIZE; i += FRAME_SIZE) {\n      let frameEnergy = 0;\n\n      // Calculate energy for this frame\n      for (let j = 0; j < FRAME_SIZE; j++) {\n        frameEnergy += Math.abs(buffer[i + j]);\n      }\n\n      // Average energy for the frame\n      frameEnergy = frameEnergy / FRAME_SIZE;\n\n      if (frameEnergy > ENERGY_THRESHOLD) {\n        consecutiveHighEnergyFrames++;\n\n        // If we've detected enough consecutive high-energy frames, consider it an interruption\n        if (consecutiveHighEnergyFrames >= CONSECUTIVE_FRAMES_THRESHOLD) {\n          elizaLogger.debug(\n            `[SttTtsPlugin] Interruption detected: energy=${frameEnergy}, ` +\n              `consecutive frames=${consecutiveHighEnergyFrames}`,\n          );\n          return true;\n        }\n      } else {\n        // Reset counter if we encounter a low-energy frame\n        consecutiveHighEnergyFrames = 0;\n      }\n    }\n\n    return false;\n  }\n\n  cleanup(): void {\n    elizaLogger.log('[SttTtsPlugin] cleanup => releasing resources');\n    this.pcmBuffers.clear();\n    this.userSpeakingTimer = null;\n    this.ttsQueue = [];\n    this.isSpeaking = false;\n    this.volumeBuffers.clear();\n  }\n\n  private async mergeAudioChunks(chunks: Int16Array[]): Promise<Int16Array> {\n    // Calculate total length of all chunks\n    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n\n    // Simple concatenation of chunks - no need for browser APIs\n    const result = new Int16Array(totalLength);\n    let offset = 0;\n\n    for (const chunk of chunks) {\n      result.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    // Check if audio is too quiet and needs amplification\n    let maxAmplitude = 0;\n    for (let i = 0; i < result.length; i++) {\n      const absValue = Math.abs(result[i]);\n      if (absValue > maxAmplitude) {\n        maxAmplitude = absValue;\n      }\n    }\n\n    elizaLogger.debug(\n      `[SttTtsPlugin] Merged ${chunks.length} audio chunks, total samples: ${totalLength}, ` +\n        `max amplitude: ${maxAmplitude}`,\n    );\n\n    // If the audio is very quiet, amplify it\n    if (maxAmplitude < 5000) {\n      // Less than ~15% of max Int16 value\n      const gainFactor = Math.min(3.0, 10000 / Math.max(1, maxAmplitude));\n      elizaLogger.debug(\n        `[SttTtsPlugin] Amplifying quiet audio by factor of ${gainFactor.toFixed(2)}`,\n      );\n\n      for (let i = 0; i < result.length; i++) {\n        // Apply gain and clamp to Int16 range\n        result[i] = Math.max(\n          -32768,\n          Math.min(32767, Math.round(result[i] * gainFactor)),\n        );\n      }\n    }\n\n    return result;\n  }\n}\n","import { messageCompletionFooter, shouldRespondFooter } from '@elizaos/core';\n\nexport const twitterShouldRespondTemplate =\n  `# Task: Decide if {{agentName}} should respond.\nAbout {{agentName}}:\n{{bio}}\n\n# INSTRUCTIONS: Determine if {{agentName}} should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\n\n# RESPONSE EXAMPLES\n{{user1}}: I just saw a really great movie\n{{user2}}: Oh? Which movie?\nResult: [IGNORE]\n\n{{agentName}}: Oh, this is my favorite scene\n{{user1}}: sick\n{{user2}}: wait, why is it your favorite scene\nResult: [RESPOND]\n\n{{user1}}: stfu bot\nResult: [STOP]\n\n{{user1}}: Hey {{agent}}, can you help me with something\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stfu plz\nResult: [STOP]\n\n{{user1}}: i need help\n{{agentName}}: how can I help you?\n{{user1}}: no. i need help from someone else\nResult: [IGNORE]\n\n{{user1}}: Hey {{agent}}, can I ask you a question\n{{agentName}}: Sure, what is it\n{{user1}}: can you ask claude to create a basic react module that demonstrates a counter\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} can you tell me a story\n{{user1}}: about a girl named elara\n{{agentName}}: Sure.\n{{agentName}}: Once upon a time, in a quaint little village, there was a curious girl named Elara.\n{{agentName}}: Elara was known for her adventurous spirit and her knack for finding beauty in the mundane.\n{{user1}}: I'm loving it, keep going\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stop responding plz\nResult: [STOP]\n\n{{user1}}: okay, i want to test something. can you say marco?\n{{agentName}}: marco\n{{user1}}: great. okay, now do it again\nResult: [RESPOND]\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} is in a room with other users and is very worried about being annoying and saying too much.\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\nIf a message is not interesting or relevant, respond with [IGNORE]\nUnless directly responding to a user, respond with [IGNORE] to messages that are very short or do not contain much information.\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\n\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\n\n{{recentMessages}}\n\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\n` + shouldRespondFooter;\n\nexport const twitterVoiceHandlerTemplate =\n  `# Task: Generate conversational voice dialog for {{agentName}}.\n    About {{agentName}}:\n    {{bio}}\n\n    # Attachments\n    {{attachments}}\n\n    # Capabilities\n    Note that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n    {{actions}}\n\n    {{messageDirections}}\n\n    {{recentMessages}}\n\n    # Instructions: Write the next message for {{agentName}}. Include an optional action if appropriate. {{actionNames}}\n    ` + messageCompletionFooter;\n"],"mappings":"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","names":["elizaLogger","authToken","ct0","guestId","existingMemories","existingMemoryIds","tweetsToSave","profile","ActionTimelineType","SearchMode","stringToUuid","elizaLogger","getEmbeddingZeroVector","getEmbeddingZeroVector","stringToUuid","elizaLogger","elizaLogger","stringToUuid","getEmbeddingZeroVector","elizaLogger","SearchMode","stringToUuid","tweet","message","response","tweetId","getEmbeddingZeroVector","composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","elizaLogger","ServiceType","elizaLogger","stringToUuid","getEmbeddingZeroVector","composeContext","ModelClass","truncateContent","ServiceType","SearchMode","composeContext","elizaLogger","generateMessageResponse","generateText","messageCompletionFooter","ModelClass","ServiceType","stringToUuid","messageCompletionFooter","elizaLogger","SearchMode","generateText","ModelClass","stringToUuid","ServiceType","composeContext","generateMessageResponse","response","elizaLogger","generateText","ModelClass","ServiceType","elizaLogger","stringToUuid","composeContext","getEmbeddingZeroVector","generateMessageResponse","ModelClass","messageCompletionFooter","shouldRespondFooter","twitterShouldRespondTemplate","EventEmitter","elizaLogger","stringToUuid","getEmbeddingZeroVector","composeContext","generateMessageResponse","ModelClass","_a","generateText","ModelClass","elizaLogger","ServiceType","elizaLogger"]}